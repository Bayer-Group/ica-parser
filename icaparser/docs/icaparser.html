<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>icaparser API documentation</title>
<meta name="description" content="Parser for JSON files from Illumina&#39;s ICA annotation pipeline." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>icaparser</code></h1>
</header>
<section id="section-intro">
<p>Parser for JSON files from Illumina's ICA annotation pipeline.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Parser for JSON files from Illumina&#39;s ICA annotation pipeline.&#34;&#34;&#34;
from operator import index
import os
import re
import gzip
import json
from pathlib import Path
from copy import copy, deepcopy
from numpy import isin
import pandas as pd
import numpy as np
import pkg_resources
from tqdm.auto import tqdm
from natsort import natsorted
import warnings

_CLINVAR_ORDERED_SIGNIFICANCES = [
    &#34;pathogenic&#34;,
    &#34;likely pathogenic&#34;,
    &#34;drug response&#34;,
    &#34;risk factor&#34;,
    &#34;protective&#34;,
    &#34;affects&#34;,
    &#34;association&#34;,
    &#34;uncertain significance&#34;,
    &#34;conflicting data from submitters&#34;,
    &#34;other&#34;,
    &#34;not provided&#34;,
    &#34;likely benign&#34;,
    &#34;benign&#34;,
]

# Adapted from https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl
# Added &#39;conservative_inframe_deletion&#39;:6
# Added &#39;structural_interaction_variant&#39;:1
# Added &#39;sequence_feature&#39;:7
_CONSEQUENCE_PRIORITY = {
    # Added because missing in vcf2maf.pl but contained in Almac&#39;s files
    &#34;conservative_inframe_deletion&#34;: 6,
    &#34;structural_interaction_variant&#34;: 1,
    &#34;sequence_feature&#34;: 7,
    # Added because missing in vcr2map.pl but contained in ICA&#39;s RNAseq
    # files. In the examples I have seen so far, &#34;transcript_variant&#34; means
    # a SNV, but not always. When investigating individual examples, the specied
    # base change is not in agreement with the reference base of the annotated
    # transcript, so it is unclear whether these changes are reliable. I assign
    # a priority of 6 to such variants and leave it up to the user to keep or
    # remove transcript_variant variants.
    &#34;transcript_variant&#34;: 6,
    # from vcf2maf.pl
    &#34;transcript_ablation&#34;: 1,  ## A feature ablation whereby the deleted region includes a transcript feature
    &#34;exon_loss_variant&#34;: 1,  ## A sequence variant whereby an exon is lost from the transcript
    &#34;splice_donor_variant&#34;: 2,  ## A splice variant that changes the 2 base region at the 5&#39; end of an intron
    &#34;splice_acceptor_variant&#34;: 2,  ## A splice variant that changes the 2 base region at the 3&#39; end of an intron
    &#34;stop_gained&#34;: 3,  ## A sequence variant whereby at least one base of a codon is changed,
    # resulting in a premature stop codon, leading to a shortened transcript
    &#34;frameshift_variant&#34;: 3,  ## A sequence variant which causes a disruption of the translational reading
    # frame, because the number of nucleotides inserted or deleted is not a
    # multiple of three
    &#34;stop_lost&#34;: 3,  # A sequence variant where at least one base of the terminator codon (stop)
    # is changed, resulting in an elongated transcript
    &#34;start_lost&#34;: 4,  ## A codon variant that changes at least one base of the canonical start codon
    &#34;initiator_codon_variant&#34;: 4,  ## A codon variant that changes at least one base of the first codon of a
    # transcript
    &#34;disruptive_inframe_insertion&#34;: 5,  ## An inframe increase in cds length that inserts one or more codons into the
    # coding sequence within an existing codon
    &#34;disruptive_inframe_deletion&#34;: 5,  ## An inframe decrease in cds length that deletes bases from the coding sequence
    # starting within an existing codon
    &#34;inframe_insertion&#34;: 5,  ## An inframe non synonymous variant that inserts bases into the coding sequence
    &#34;inframe_deletion&#34;: 5,  ## An inframe non synonymous variant that deletes bases from the coding sequence
    &#34;protein_altering_variant&#34;: 5,  ## A sequence variant which is predicted to change the protein encoded in the
    # coding sequence
    &#34;missense_variant&#34;: 6,  ## A sequence variant, that changes one or more bases, resulting in a different
    # amino acid sequence but where the length is preserved
    &#34;conservative_missense_variant&#34;: 6,  ## A sequence variant whereby at least one base of a codon is changed resulting
    # in a codon that encodes for a different but similar amino acid. These
    # variants may or may not be deleterious
    &#34;rare_amino_acid_variant&#34;: 6,  ## A sequence variant whereby at least one base of a codon encoding a rare amino
    # acid is changed, resulting in a different encoded amino acid
    &#34;transcript_amplification&#34;: 7,  ## A feature amplification of a region containing a transcript
    &#34;splice_region_variant&#34;: 8,  ## A sequence variant in which a change has occurred within the region of the
    # splice site, either within 1-3 bases of the exon or 3-8 bases of the intron
    &#34;start_retained_variant&#34;: 9,  ## A sequence variant where at least one base in the start codon is changed, but
    # the start remains
    &#34;stop_retained_variant&#34;: 9,  ## A sequence variant where at least one base in the terminator codon is changed,
    # but the terminator remains
    &#34;synonymous_variant&#34;: 9,  ## A sequence variant where there is no resulting change to the encoded amino
    # acid
    &#34;incomplete_terminal_codon_variant&#34;: 10,  ## A sequence variant where at least one base of the final codon of an
    # incompletely annotated transcript is changed
    &#34;coding_sequence_variant&#34;: 11,  ## A sequence variant that changes the coding sequence
    &#34;mature_miRNA_variant&#34;: 11,  ## A transcript variant located with the sequence of the mature miRNA
    &#34;exon_variant&#34;: 11,  ## A sequence variant that changes exon sequence
    &#34;5_prime_UTR_variant&#34;: 12,  ## A UTR variant of the 5&#39; UTR
    &#34;5_prime_UTR_premature_start_codon_gain_variant&#34;: 12,  # snpEff-specific effect, creating a start codon in 5&#39; UTR
    &#34;3_prime_UTR_variant&#34;: 12,  ## A UTR variant of the 3&#39; UTR
    &#34;non_coding_exon_variant&#34;: 13,  ## A sequence variant that changes non-coding exon sequence
    &#34;non_coding_transcript_exon_variant&#34;: 13,  ## snpEff-specific synonym for non_coding_exon_variant
    &#34;non_coding_transcript_variant&#34;: 14,  ## A transcript variant of a non coding RNA gene
    &#34;nc_transcript_variant&#34;: 14,  ## A transcript variant of a non coding RNA gene (older alias for
    # non_coding_transcript_variant)
    &#34;intron_variant&#34;: 14,  ## A transcript variant occurring within an intron
    &#34;intragenic_variant&#34;: 14,  ## A variant that occurs within a gene but falls outside of all transcript
    # features. This occurs when alternate transcripts of a gene do not share
    # overlapping sequence
    &#34;INTRAGENIC&#34;: 14,  ## snpEff-specific synonym of intragenic_variant
    &#34;NMD_transcript_variant&#34;: 15,  ## A variant in a transcript that is the target of NMD
    &#34;upstream_gene_variant&#34;: 16,  ## A sequence variant located 5&#39; of a gene
    &#34;downstream_gene_variant&#34;: 16,  ## A sequence variant located 3&#39; of a gene
    &#34;TFBS_ablation&#34;: 17,  ## A feature ablation whereby the deleted region includes a transcription factor
    # binding site
    &#34;TFBS_amplification&#34;: 17,  ## A feature amplification of a region containing a transcription factor binding
    # site
    &#34;TF_binding_site_variant&#34;: 17,  ## A sequence variant located within a transcription factor binding site
    &#34;regulatory_region_ablation&#34;: 17,  ## A feature ablation whereby the deleted region includes a regulatory region
    &#34;regulatory_region_amplification&#34;: 17,  ## A feature amplification of a region containing a regulatory region
    &#34;regulatory_region_variant&#34;: 17,  ## A sequence variant located within a regulatory region
    &#34;regulatory_region&#34;: 17,  ## snpEff-specific effect that should really be regulatory_region_variant
    &#34;feature_elongation&#34;: 18,  ## A sequence variant that causes the extension of a genomic feature, with
    # regard to the reference sequence
    &#34;feature_truncation&#34;: 18,  ## A sequence variant that causes the reduction of a genomic feature, with
    # regard to the reference sequence
    &#34;intergenic_variant&#34;: 19,  ## A sequence variant located in the intergenic region, between genes
    &#34;intergenic_region&#34;: 19,  ## snpEff-specific effect that should really be intergenic_variant
    &#34;&#34;: 20,
}

_BIOTYPE_PRIORITY = {
    &#34;prime3_overlapping_ncrna&#34;: 5,  ## added by Henrik, probably a typo in Almac&#39;s annotation,
    # should be 3prime_overlapping_ncrna which has prio 5
    &#34;protein_coding&#34;: 1,  ## Contains an open reading frame (ORF)
    &#34;LRG_gene&#34;: 2,  ## Gene in a &#34;Locus Reference Genomic&#34; region known to have disease-related
    # sequence variations
    &#34;IG_C_gene&#34;: 2,  ## Immunoglobulin (Ig) variable chain genes imported or annotated according
    # to the IMGT
    &#34;IG_D_gene&#34;: 2,  ## Immunoglobulin (Ig) variable chain genes imported or annotated according
    #  to the IMGT
    &#34;IG_J_gene&#34;: 2,  ## Immunoglobulin (Ig) variable chain genes imported or annotated according
    # to the IMGT
    &#34;IG_LV_gene&#34;: 2,  ## Immunoglobulin (Ig) variable chain genes imported or annotated according
    # to the IMGT
    &#34;IG_V_gene&#34;: 2,  ## Immunoglobulin (Ig) variable chain genes imported or annotated according
    # to the IMGT
    &#34;TR_C_gene&#34;: 2,  ## T-cell receptor (TcR) genes imported or annotated according to the IMGT
    &#34;TR_D_gene&#34;: 2,  ## T-cell receptor (TcR) genes imported or annotated according to the IMGT
    &#34;TR_J_gene&#34;: 2,  ## T-cell receptor (TcR) genes imported or annotated according to the IMGT
    &#34;TR_V_gene&#34;: 2,  ## T-cell receptor (TcR) genes imported or annotated according to the IMGT
    &#34;miRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;snRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;snoRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;ribozyme&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;tRNA&#34;: 3,  ##Added by Y. Boursin
    &#34;sRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;scaRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;rRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;scRNA&#34;: 3,  ## Non-coding RNA predicted using sequences from Rfam and miRBase
    &#34;lincRNA&#34;: 3,  ## Long, intervening noncoding (linc) RNAs, that can be found in evolutionarily
    # conserved, intergenic regions
    &#34;lncRNA&#34;: 3,  ## Replaces 3prime_overlapping_ncRNA, antisense, bidirectional_promoter_lncRNA,
    # lincRNA, macro_lncRNA, non_coding, processed_transcript, sense_intronic
    # and sense_overlapping
    &#34;bidirectional_promoter_lncrna&#34;: 3,  ## A non-coding locus that originates from within the promoter region of a
    # protein-coding gene, with transcription proceeding in the opposite
    # direction on the other strand
    &#34;bidirectional_promoter_lncRNA&#34;: 3,  ## A non-coding locus that originates from within the promoter region of a
    # protein-coding gene, with transcription proceeding in the opposite
    # direction on the other strand
    &#34;known_ncrna&#34;: 4,
    &#34;vaultRNA&#34;: 4,  ## Short non coding RNA genes that form part of the vault ribonucleoprotein
    # complex
    &#34;macro_lncRNA&#34;: 4,  ## unspliced lncRNAs that are several kb in size
    &#34;Mt_tRNA&#34;: 4,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;Mt_rRNA&#34;: 4,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;antisense&#34;: 5,  ## Has transcripts that overlap the genomic span (i.e. exon or introns) of a
    # protein-coding locus on the opposite strand
    &#34;antisense_RNA&#34;: 5,  ## Alias for antisense (Y. Boursin)
    &#34;sense_intronic&#34;: 5,  ## Long non-coding transcript in introns of a coding gene that does not overlap
    # any exons
    &#34;sense_overlapping&#34;: 5,  ## Long non-coding transcript that contains a coding gene in its intron on the
    # same strand
    &#34;3prime_overlapping_ncrna&#34;: 5,  ## Transcripts where ditag and/or published experimental data strongly supports
    # the existence of short non-coding transcripts transcribed from the 3&#39;UTR
    &#34;3prime_overlapping_ncRNA&#34;: 5,  ## Transcripts where ditag and/or published experimental data strongly supports
    # the existence of short non-coding transcripts transcribed from the 3&#39;UTR
    &#34;misc_RNA&#34;: 5,  ## Non-coding RNA predicted using sequences from RFAM and miRBase
    &#34;non_coding&#34;: 5,  ## Transcript which is known from the literature to not be protein coding
    &#34;regulatory_region&#34;: 6,  ## A region of sequence that is involved in the control of a biological process
    &#34;disrupted_domain&#34;: 6,  ## Otherwise viable coding region omitted from this alternatively spliced
    # transcript because the splice variation affects a region coding for a
    # protein domain
    &#34;processed_transcript&#34;: 6,  ## Doesn&#39;t contain an ORF
    &#34;TEC&#34;: 6,  ## To be Experimentally Confirmed. This is used for non-spliced EST clusters
    # that have polyA features. This category has been specifically created for
    # the ENCODE project to highlight regions that could indicate the presence of
    # protein coding genes that require experimental validation, either by 5&#39;
    # RACE or RT-PCR to extend the transcripts, or by confirming expression of
    # the putatively-encoded peptide with specific antibodies
    &#34;TF_binding_site&#34;: 7,  ## A region of a nucleotide molecule that binds a Transcription Factor or
    # Transcription Factor complex
    &#34;CTCF_binding_site&#34;: 7,  ## A transcription factor binding site with consensus sequence CCGCGNGGNGGCAG,
    # bound by CCCTF-binding factor
    &#34;promoter_flanking_region&#34;: 7,  ## A region immediately adjacent to a promoter which may or may not contain
    # transcription factor binding sites
    &#34;enhancer&#34;: 7,  ## A cis-acting sequence that increases the utilization of (some) eukaryotic
    # promoters, and can function in either orientation and in any location
    # (upstream or downstream) relative to the promoter
    &#34;promoter&#34;: 7,  ## A regulatory_region composed of the TSS(s) and binding sites for
    # TF_complexes of the basal transcription machinery
    &#34;open_chromatin_region&#34;: 7,  ## A DNA sequence that in the normal state of the chromosome corresponds to an
    # unfolded, un-complexed stretch of double-stranded DNA
    &#34;retained_intron&#34;: 7,  ## Alternatively spliced transcript believed to contain intronic sequence
    # relative to other, coding, variants
    &#34;nonsense_mediated_decay&#34;: 7,  ## If the coding sequence (following the appropriate reference) of a transcript
    # finishes &gt;50bp from a downstream splice site then it is tagged as NMD. If
    # the variant does not cover the full reference coding sequence then it is
    # annotated as NMD if NMD is unavoidable i.e. no matter what the exon
    # structure of the missing portion is the transcript will be subject to NMD
    &#34;non_stop_decay&#34;: 7,  ## Transcripts that have polyA features (including signal) without a prior stop
    # codon in the CDS, i.e. a non-genomic polyA tail attached directly to the
    # CDS without 3&#39; UTR. These transcripts are subject to degradation
    &#34;ambiguous_orf&#34;: 7,  ## Transcript believed to be protein coding, but with more than one possible
    # open reading frame
    &#34;pseudogene&#34;: 8,  ## Have homology to proteins but generally suffer from a disrupted coding
    # sequence and an active homologous gene can be found at another locus.
    # Sometimes these entries have an intact coding sequence or an open but
    # truncated ORF, in which case there is other evidence used (for example
    # genomic polyA stretches at the 3&#39; end) to classify them as a pseudogene.
    # Can be further classified as one of the following
    &#34;processed_pseudogene&#34;: 8,  ## Pseudogene that lack introns and is thought to arise from reverse
    # transcription of mRNA followed by reinsertion of DNA into the genome
    &#34;polymorphic_pseudogene&#34;: 8,  ## Pseudogene owing to a SNP/DIP but in other individuals/haplotypes/strains
    # the gene is translated
    &#34;retrotransposed&#34;: 8,  ## Pseudogene owing to a reverse transcribed and re-inserted sequence
    &#34;translated_processed_pseudogene&#34;: 8,  ## Pseudogenes that have mass spec data suggesting that they are also translated
    &#34;translated_unprocessed_pseudogene&#34;: 8,  ## Pseudogenes that have mass spec data suggesting that they are also translated
    &#34;transcribed_processed_pseudogene&#34;: 8,  ## Pseudogene where protein homology or genomic structure indicates a pseudogene,
    # but the presence of locus-specific transcripts indicates expression
    &#34;transcribed_unprocessed_pseudogene&#34;: 8,  ## Pseudogene where protein homology or genomic structure indicates a pseudogene,
    # but the presence of locus-specific transcripts indicates expression
    &#34;transcribed_unitary_pseudogene&#34;: 8,  ##Pseudogene where protein homology or genomic structure indicates a pseudogene,
    # but the presence of locus-specific transcripts indicates expression
    &#34;unitary_pseudogene&#34;: 8,  ## A species specific unprocessed pseudogene without a parent gene, as it has an
    # active orthologue in another species
    &#34;unprocessed_pseudogene&#34;: 8,  ## Pseudogene that can contain introns since produced by gene duplication
    &#34;Mt_tRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;tRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;snoRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;snRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;scRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;rRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;misc_RNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;miRNA_pseudogene&#34;: 8,  ## Non-coding RNAs predicted to be pseudogenes by the Ensembl pipeline
    &#34;IG_C_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;IG_D_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;IG_J_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;IG_V_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;TR_J_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;TR_V_pseudogene&#34;: 8,  ## Inactivated immunoglobulin gene
    &#34;artifact&#34;: 9,  ## Used to tag mistakes in the public databases (Ensembl/SwissProt/Trembl)
    &#34;&#34;: 10,
}

# Read, sort and rank the VEP consequences from a file in the data directory
vep_csq = pd.read_csv(
    pkg_resources.resource_stream(__name__, &#34;data/vep_consequences.txt&#34;), sep=&#34;\t&#34;
)
vep_csq = vep_csq.set_index(&#34;SO term&#34;)
vep_csq[&#34;rank&#34;] = list(range(1, 1 + vep_csq.shape[0]))
vep_csq[&#34;priority&#34;] = [_CONSEQUENCE_PRIORITY[x] for x in vep_csq.index]
vep_csq = vep_csq.sort_values([&#34;priority&#34;, &#34;rank&#34;])

# Read the oncogene / tumor suppressor gene definition from a file in the data directory
gene_type = pd.read_csv(
    pkg_resources.resource_stream(
        __name__, &#34;data/cancer_genes_union_TCGA_COSMIC_manual.tsv&#34;
    ),
    sep=&#34;\t&#34;,
    index_col=&#34;gene_symbol&#34;,
)


def strip_json_file(ifname, ofname):
    &#34;&#34;&#34;Reduce the JSON file size by keeping only &#39;PASS&#39; variants.

    JSON files from Illumina&#39;s ICA pipeline can be very large because they
    contain any deviation from the reference genome, irrespective of the
    quality of the mutation call. Gzip compressed JSON files with sizes in the
    gigabyte range cannot be processed by JSON packages that read the entire
    file into memory. It is necessary to first reduce the size of JSON files by
    removing all variants that do not meet Illumina&#39;s quality criteria.

    This function reads a single JSON file and creates a single JSON outpout
    file by removing all variants that do not pass Illumina&#39;s quality criteria.

    Args:
        ifname: name of the  input file
        ofname: name of the output file

    Returns:
        Nothing
    &#34;&#34;&#34;
    if ifname == ofname:
        raise ValueError(&#34;ifname and ofname must be different&#34;)
    odname = os.path.dirname(ofname)
    os.makedirs(odname, exist_ok=True)
    header = &#34;&#34;
    is_header_line = True
    is_position_line = False
    is_first_position_line = False
    is_gene_line = False
    is_first_gene_line = False
    gene_section_line = &#39;],&#34;genes&#34;:[&#39;
    end_line = &#34;]}&#34;
    with gzip.open(ifname, &#34;rt&#34;) as fin:
        with gzip.open(ofname, &#34;wt&#34;) as fout:
            for line in fin:
                trim_line = line.strip()
                if is_header_line:
                    print(trim_line, file=fout)
                    is_header_line = False
                    is_position_line = True
                    is_first_position_line = True
                    continue
                if trim_line == gene_section_line:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=fout)
                    is_gene_line = True
                    is_first_gene_line = True
                    is_position_line = False
                    continue
                elif trim_line == end_line:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=fout)
                    break
                else:
                    if is_position_line:
                        ## remove the trailing &#39;,&#39; if there is
                        position_json = trim_line.rstrip(&#34;,&#34;)
                        position = json.loads(position_json)
                        if &#34;PASS&#34; in position[&#34;filters&#34;]:
                            if is_first_position_line:
                                finish_prev_line = &#34;&#34;
                            else:
                                finish_prev_line = &#34;,\n&#34;
                            print(
                                finish_prev_line,
                                position_json,
                                sep=&#34;&#34;,
                                end=&#34;&#34;,
                                file=fout,
                            )
                            is_first_position_line = False
                    if is_gene_line:
                        ## remove the trailing &#39;,&#39; if there is
                        gene_json = trim_line.rstrip(&#34;,&#34;)
                        if is_first_gene_line:
                            finish_prev_line = &#34;&#34;
                        else:
                            finish_prev_line = &#34;,\n&#34;
                        print(finish_prev_line, gene_json, sep=&#34;&#34;, end=&#34;&#34;, file=fout)
                        is_first_gene_line = False


def strip_json_files(source_dir, target_dir, pattern=&#34;*.json.gz&#34;):
    &#34;&#34;&#34;Strip all JSON files of a project by keeping only &#39;PASS&#39; variants.

    JSON files from Illumina&#39;s ICA pipeline can be very large because they
    contain any deviation from the reference genome, irrespective of the
    quality of the mutation call. Gzip compressed JSON files with sizes in the
    gigabyte range cannot be processed by JSON packages that read the entire
    file into memory. It is necessary to first reduce the size of JSON files by
    removing all variants that do not meet Illumina&#39;s quality criteria.

    This function searches `source_dir` recursively for all files matching the
    `file_pattern`. Each of those files is processed and a stripped version
    keeping only variants that PASS Illumina&#39;s quality criteria is created. The
    output file has the same name as the input file. The directory structure
    below `source_dir` is replicated in `target_dir`. Output files get the
    suffix &#39;_filtered.json.gz&#39;.‚

    Args:
        source_dir: directory where to search for input JSON files
        target_dir: directory where to save the stripped outpout JSON files
        file_pattern: files matching this pattern will be processed

    Returns:
        Nothing

    Example:
        &gt;&gt;&gt; strip_json_files(&#39;../Data/Original&#39;, &#39;../Data/Derived&#39;)
    &#34;&#34;&#34;
    source_dir = Path(source_dir).absolute()
    target_dir = Path(target_dir).absolute()
    if source_dir == target_dir:
        raise ValueError(&#34;source and target directory must be different&#34;)
    for path in tqdm(list(source_dir.rglob(pattern))):
        ifname = path.as_posix()
        ofname = ifname.replace(source_dir.as_posix(), target_dir.as_posix(), 1)
        ofname = ofname.removesuffix(&#34;.json.gz&#34;) + &#34;_filtered.json.gz&#34;
        tqdm.write(&#34;Stripping &#34; + ifname)
        strip_json_file(ifname, ofname)


def get_dna_json_files(base_dir, pattern=&#34;*MergedVariants_Annotated_filtered.json.gz&#34;):
    &#34;&#34;&#34;Find DNA annotation JSON files in or below `base_dir`.

    Searches for ICA DNA annotation JSON files in and below `base_dir`.
    All file names matching `pattern` are returned.

    Args:
        base_dir: base directory of directory subtree where to search
                  for DNA annotation JSON files
        pattern:  files names matching this pattern are returned

    Returns:
        A list of file names
    &#34;&#34;&#34;
    files = [x.as_posix() for x in Path(base_dir).rglob(pattern)]
    files = sorted(files)
    return files


def get_header(file):
    &#34;&#34;&#34;Extract the header element from a ICA JSON file.

    Args:
        file: name of the ICA JSON file

    Returns:
        A dictionary with the header from the JSON file
    &#34;&#34;&#34;
    with gzip.open(file, &#34;rt&#34;) as f:
        line = next(f)
    trim_line = line.strip()
    header = trim_line[10:-14]
    header = json.loads(header)
    return header


def get_sample(file, suffix=&#34;(-D[^.]*)?\\.bam&#34;):
    &#34;&#34;&#34;Extract the sample name from a ICA JSON file.

    Args:
        file: name of the ICA JSON file
        suffix: regular expression to remove from the sample name in the JSON
            file. Defaults to &#39;(-D[^.]*)?\\.bam&#39;.

    Returns:
        A string with the name of the sample annotated in the JSON file
    &#34;&#34;&#34;
    header = get_header(file)
    sample = header[&#34;samples&#34;][0]
    sample = re.sub(suffix, &#34;&#34;, sample)
    return sample


def get_header_scalars(file):
    &#34;&#34;&#34;Extract a table with all scalar attributes from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    header = get_header(file)
    sample = get_sample(file)
    df = pd.DataFrame([x for x in header.items() if not isinstance(x[1], list)])
    df = df.rename(columns={0: &#34;Attribute&#34;, 1: sample})
    return df


def get_data_sources(file):
    &#34;&#34;&#34;Extract a table with annotation data sources from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    header = get_header(file)
    df = pd.DataFrame(header[&#34;dataSources&#34;])
    return df


def get_pipeline_metadata(files):
    &#34;&#34;&#34;Extract a table with metadata annotation pipeline run from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    df = get_header_scalars(files[0])
    for fname in files[1:]:
        df = pd.merge(df, get_header_scalars(fname), on=&#34;Attribute&#34;, how=&#34;outer&#34;)
    df = df.set_index(&#34;Attribute&#34;).transpose()
    df.index.rename(&#34;Sample&#34;, inplace=True)
    return df


def _get_branch(file, key):
    &#34;&#34;&#34;Extract a subsection (branch) of the ICA JSON file.

    This is a helper function which is not supposed to be used by the end user.

    Args:
        file: name of the ICA JSON file
        key:  name of the top level element to extract (`positions` or `genes`)

    Returns:
        A list.

    &#34;&#34;&#34;
    with gzip.open(file, &#34;rt&#34;) as f:
        data = json.load(f)
    if key in data.keys():
        return data[key]
    else:
        return list()


def cleanup_cosmic(positions):
    &#34;&#34;&#34;Remove Cosmic entries with alleles not matching the variant alleles.

    ICA attaches Cosmic entries to variants based on position only, which
    leads to wrong assignments of Cosmic entries to variants. This function
    removes all Cosmic entries from a variant for which reference and altered
    alleles do not match those of the variant.

    Filtering is done in place.

    Args:
        positions: list of positions to clean up

    Returns:
        A list of positions with cleaned up Cosmic entries
    &#34;&#34;&#34;
    for p in positions:
        for v in p[&#34;variants&#34;]:
            if &#34;cosmic&#34; not in v:
                continue
            cosmic = []
            for c in v.get[&#34;cosmic&#34;]:
                # if c[&#39;refAllele&#39;] == variant[&#39;refAllele&#39;] and c[&#39;altAllele&#39;] == variant[&#39;altAllele&#39;]:
                if c.get(&#34;isAlleleSpecific&#34;, False):
                    cosmic.append(c)
            if len(cosmic) &gt; 0:
                v[&#34;cosmic&#34;] = cosmic
            else:
                del v[&#34;cosmic&#34;]
    return positions


def get_positions(file, variant_filters=[], transcript_filters=[]):
    &#34;&#34;&#34;Extract all positions from a ICA JSON file.

    The sample id is stored as an additional new attribute of the
    `samples` element of a position. The `samples` element is a list,
    although ICA usually only creates single sample JSON files.

    Args:
        file: name of the ICA JSON file
        variant_filters: any filters to apply to variants.
                Filters shall return True to keep a variant.
        transcript_filters: any filters to apply to transcripts.
                Filters shall return True to keep a transcript.

    Returns:
        A list

    Examples:
        &gt;&gt;&gt; transcript_filters = [
                lambda x: x.get(&#39;source&#39;, &#39;&#39;) == &#39;Ensembl&#39;,
                lambda x: x.get(&#39;hgnc&#39;, &#39;&#39;) == &#39;KRAS&#39;
            ]
        &gt;&gt;&gt; positions = icap.get_sample_positions(
                json_file,
                transcript_filters = transcript_filters
            )
        &gt;&gt;&gt; print(positions[0][&#39;samples&#39;][0][&#39;sampleId&#39;])
    &#34;&#34;&#34;
    positions = _get_branch(file, &#34;positions&#34;)
    positions = add_gene_types(positions)
    for vf in variant_filters:
        positions = filter_positions_by_variants(positions, vf)
    for tf in transcript_filters:
        positions = filter_positions_by_transcripts(positions, tf)
    sample_id = get_sample(file)
    for p in positions:
        p[&#34;samples&#34;][0][&#34;sampleId&#34;] = sample_id
    return positions


def get_multi_sample_positions(files, *args, **kwargs):
    &#34;&#34;&#34;Extract all positions for a set of ICA JSON files.

    The sample id is stored as an additional new attribute of the
    `samples` element of a position. The `samples` element is a list,
    although ICA usually only creates single sample JSON files.

    Args:
        files: names of the ICA JSON files
        args: extra arguments forwarded to get_positions()
        kwargs: extra named arguments forwarded to get_positions()

    Returns:
        A list

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions = icap.get_multi_sample_positions(json_files)
        &gt;&gt;&gt; print(positions[0][&#39;samples&#39;][0][&#39;sampleId&#39;])
    &#34;&#34;&#34;
    positions = []
    for f in tqdm(files):
        positions += get_positions(f, *args, **kwargs)
    return positions


def get_genes(file):
    &#34;&#34;&#34;Extract gene annotation from a ICA JSON file.

    The `genes` section of ICA JSON files is optional. If this section
    is not included in the file, an empty list is returned.

    Args:
        file: name of the ICA JSON file

    Returns:
        A list
    &#34;&#34;&#34;
    return _get_branch(file, &#34;genes&#34;)


def get_position_by_coordinates(positions, chromosome, position):
    &#34;&#34;&#34;Extract a particular position from a position list.

    Args:
        positions: a list of positions
        chromosome: name of the chromosome
        position: numeric posion on the chromosome

    Returns:
        A dict

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_position_by_coordinates(positions, &#39;chr1&#39;, 204399064)
    &#34;&#34;&#34;
    filter_func = lambda x: x[&#34;chromosome&#34;] == chromosome and x[&#34;position&#34;] == int(
        position
    )
    return list(filter(filter_func, positions))[0]


def get_max_af(variant, source, cohorts = None):
    &#34;&#34;&#34;Get the maximum allele frequency for a particular annotation source.

    Get the maximum allele frequency across all cohorts annotated by the
    annotation source.

    Args:
        variant: the variant to investigate
        source: the annotation source to use
        cohorts: subpopulations to include; include all if cohorts == None

    Returns:
        A float

    Example:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_max_af(variant, &#39;gnomad&#39;)
    &#34;&#34;&#34;
    if not source in variant:
        return 0
    max_af = 0
    for k, v in variant[source].items():
        if k.endswith(&#34;Af&#34;):
            if not cohorts or k.replace(&#34;Af&#34;, &#34;&#34;) in cohorts:
                max_af = max(max_af, v)
    return max_af


def get_gnomad_max_af(
        variant,
        cohorts = [&#34;afr&#34;, &#34;amr&#34;, &#34;eas&#34;, &#34;nfe&#34;, &#34;sas&#34;]
        ):
    &#34;&#34;&#34;Get the maximum allele frequency for gnomAD.

    Get the maximum allele frequences across all major cohorts annotated
    by gnomAD, excluding bottleneck populations (Ashkenazy Jews and Finish)
    and _other_.

    Args:
        variant: the variant to investigate
        cohorts: subpopulations to include

    Returns:
        A float
    &#34;&#34;&#34;
    
    return get_max_af(variant, &#34;gnomad&#34;, cohorts)


def get_gnomad_exome_max_af(
        variant,
        cohorts = [&#34;afr&#34;, &#34;amr&#34;, &#34;eas&#34;, &#34;nfe&#34;, &#34;sas&#34;]
        ):
    &#34;&#34;&#34;Get the maximum allele frequency for gnomAD Exome.

    Get the maximum allele frequences across all major cohorts annotated
    by gnomAD, Exome  excluding bottleneck populations (Ashkenazy Jews and
    Finish) and _other_.

    Args:
        variant: the variant to investigate
        cohorts: subpopulations to include

    Returns:
        A float
    &#34;&#34;&#34;
    return get_max_af(variant, &#34;gnomadExome&#34;, cohorts)


def get_onekg_max_af(variant):
    &#34;&#34;&#34;Get the maximum allele frequency for the 1000 Genomes Project.

    Get the maximum allele frequences across all cohorts annotated
    by the 1000 Genomes Project.

    Args:
        variant: the variant to investigate

    Returns:
        A float
    &#34;&#34;&#34;
    return get_max_af(variant, &#34;oneKg&#34;)


def get_cosmic_max_sample_count(
    variant, only_fully_annotated=False, only_allele_specific=True
):
    &#34;&#34;&#34;Get the maximum sample count for all Cosmic annotations of a variant.

    A variant can have no, one or multiple associated Cosmic identifiers.
    This function returns the maximum sample count of all Cosmic identifers.
    For each Cosmic identifiers, sample numbers are summed up across all indications.
    Returns 0 if no Cosmic identifier exists for this variant.

    The &#39;only_fully_annotated&#39; argument can be used to exclude Cosmic entries
    that have no &#39;cancerTypesAndCounts&#39; annotation. If, for example, the
    Cosmic VCF file used by ICA contained all Cosmic variants, but the
    Cosmic TSV file used by ICA contained only Cancer Census variants, then
    a variant that is in the VCF but not the TSV will have a simply annotation
    without &#39;cancerTypesAndCounts&#39;, &#39;cancerSitesAndCounts&#39;, &#39;tiersAndCounts&#39;.
    So when setting &#39;only_fully_annotated&#39; to True, only samples having a mutation
    from the Cancer Census will be counted.

    The &#39;only_allele_specific&#39; argument is used to exclude Cosmic entries that
    annotate the same chromosomal location but an allele that is different from
    the allele of the annotated variant. ICA annotates a variant with all
    Cosmic entries for that chromosomal location, irrespective of alleles.
    When counting Cosmic samples, this leads to an overestimation of Cosmic
    sample counts for a particular variant. Therefore, &#39;only_allele_specific&#39;
    is True by default to count only samples from Cosmic entries with matching
    alleles. Occasionally, it may be desired, though, to count all samples with
    mutations at a given position, irrespective of allele. For example, several
    different alleles at a functional site of a gene can lead to function-disrupting    
    mutations, so we want to get the maximum sample count for any allele at
    that position. One might also think of adding the samnple counts for all
    Cosmic entries annotating a variant, but this does not work currently due
    to redundancy of Cosmic entries. Older Cosmic versions often included the
    same sample in different Cosmic entries. And newer Cosmic versions often
    have multiple entries for an allele, one for each transcript variant, with
    the same underlying samples.

    Args:
        variant:              the variant to investigate
        only_fully_annotated: consider only consmic entries which are fully
                              annotated, i.e. which have &#39;cancerTypesAndCounts&#39;
        only_allele_specific: consider only cosmic entries with alleles
                              matching the allele of the annotated variant

    Returns:
        An integer
    &#34;&#34;&#34;
    max_count = 0
    for cosmic_entry in variant.get(&#34;cosmic&#34;, []):
        if only_fully_annotated and &#34;cancerTypesAndCounts&#34; not in cosmic_entry:
            continue
        if only_allele_specific and not cosmic_entry.get(&#34;isAlleleSpecific&#34;, False):
            continue
        max_count = max(max_count, cosmic_entry.get(&#34;sampleCount&#34;, 0))
    return max_count


def get_cosmic_cancer_gene_census_tier(variant):
    &#34;&#34;&#34;Get the highest Cosmic Cancer Gene Census tier of a variant.

    A variant can have no, one or multiple associated Cosmic identifiers.
    This function returns the highest &#39;tier&#39; for all of the Cosmic Cancer
    Gene Census entries for a variant. There are two tiers, &#39;1&#39;, and &#39;2&#39;.
    Tier &#39;1&#39; is assigned to genes with documented activity relevant to cancer,
    and tier &#39;2&#39; is assigned to genes with strong indications of a role in
    cancer but with less extensive available evidence.

    It is important to understand that this is the tier for a gene, not for a
    particular variant, so it must not be mistaken with the Cosmic Cancer
    Mutation Census tiers.
    
    See https://cancer.sanger.ac.uk/census for a detailed description of tiers.

    Args:
        variant:    the variant to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    best_tier = pd.NA
    for cosmic_entry in variant.get(&#34;cosmic&#34;, []):
        if not cosmic_entry.get(&#34;isAlleleSpecific&#34;, False):
            continue
        for tier_entry in cosmic_entry.get(&#34;tiersAndCounts&#34;, []):
            tier = int(tier_entry[&#34;tier&#34;])
            if best_tier is pd.NA:
                best_tier = tier
            else:
                best_tier = min(tier, best_tier)
    return best_tier


def get_clinvar_max_significance(
    variant, ordered_significances=_CLINVAR_ORDERED_SIGNIFICANCES
):
    &#34;&#34;&#34;Get the maximum signifinance for all ClinVar annotations of a variant.

    Args:
        variant: the variant to investigate
        ordered_significances: ranked order of ClinVar significances

    Returns:
        A string
    &#34;&#34;&#34;
    if &#34;clinvar&#34; not in variant:
        return &#34;none&#34;
    significance_ranks = dict(
        zip(ordered_significances, list(range(len(ordered_significances))))
    )
    best_rank = max(significance_ranks.values()) + 1
    max_significance = &#34;none&#34;
    for clinvar in variant[&#34;clinvar&#34;]:
        for significance in clinvar[&#34;significance&#34;]:
            if significance not in significance_ranks:
                continue
            rank = significance_ranks[significance]
            if rank &lt; best_rank:
                best_rank = rank
                max_significance = significance
    return max_significance


def common_variant_filter(variant, max_af=0.01):
    &#34;&#34;&#34;Get a variant filter based on GnomAD, GnomAd Exome, and 1000 Genomes.

    Returns True if none of the maximum allele frequencies from GnomAD,
    GnomAD Exome and 1000 Genomes is larger than `max_af`.

    Args:
        variant: the variant to investigate
        max_af: the mixum allele frequences threshold

    Returns:
        A bool
    &#34;&#34;&#34;
    passed = (
        get_gnomad_max_af(variant) &lt;= max_af
        and get_gnomad_exome_max_af(variant) &lt;= max_af
        and get_onekg_max_af(variant) &lt;= max_af
    )
    return passed


def _filter_items(items, filter_func, sub_items_name):
    &#34;&#34;&#34;Filter items based on a filter for subitems.

    Args:
        items: list of items to filter
        filter_func: function returning a bool for each sub item
        sub_items_name: each item is a dict, and this is the key
                        in this item dict for which the values
                        are a list of sub items

    Returns:
        A list
    &#34;&#34;&#34;
    filtered_items = []
    for item in items:
        if sub_items_name not in item:
            continue
        sub_items = item[sub_items_name]
        filtered_sub_items = list(filter(filter_func, sub_items))
        if filtered_sub_items:
            filtered_item = deepcopy(item)
            filtered_item[sub_items_name] = filtered_sub_items
            filtered_items.append(filtered_item)
    return filtered_items


def filter_positions_by_variants(positions, filter_func):
    &#34;&#34;&#34;Filter positions based on a filter function for variants.

    Apply a filter function to all variants of each position.
    Variants not passing the filter are removed from a position.
    Positions without any variants passing the filter are removed
    from the returned list.

    Args:
        positions: list of positions to filter
        filter_func: function taking a variant and returning a bool.
                     True means to keep the variant.

    Returns:
        A list

    Example:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; ax_af = 0.01
        &gt;&gt;&gt; is_not_common_variant = lambda x: icap.common_variant_filter(x, max_af)
        &gt;&gt;&gt; non_common_positions = icap.filter_positions_by_variants(
                positions,
                is_not_common_variant
            )
    &#34;&#34;&#34;
    return _filter_items(positions, filter_func, &#34;variants&#34;)


def filter_variants_by_transcripts(variants, filter_func):
    &#34;&#34;&#34;Filter variants based on a filter function for transcripts.

    Apply a filter function to all transcripts of each variant.
    Transcripts not passing the filter are removed from a variant.
    Variants without any transcripts passing the filter are removed
    from the returned list.

    Args:
        variants: list of variants to filter
        filter_func: function taking a transcript and returning a bool.
                     True means to keep the transcript.

    Returns:
        A list
    &#34;&#34;&#34;
    return _filter_items(variants, filter_func, &#34;transcripts&#34;)


def filter_positions_by_transcripts(positions, filter_func):
    &#34;&#34;&#34;Filter positions based on a filter function for transcripts.

    Apply a filter function to all transcripts of each position.
    Transcripts not passing the filter are removed from a position.
    Positions without any transcripts passing the filter are removed
    from the returned list.

    Args:
        positions: list of positions to filter
        filter_func: function taking a transcript and returning a bool.
                     True means to keep the transcript.

    Returns:
        A list

    Example:
        &gt;&gt;&gt; is_canonical_transcript = lambda x: x.get(&#39;isCanonical&#39;, False)
        &gt;&gt;&gt; canonical_positions = icap.filter_positions_by_transcripts(
                non_common_positions,
                is_canonical_transcript
            )
    &#34;&#34;&#34;
    filtered_positions = []
    for position in positions:
        variants = position[&#34;variants&#34;]
        filtered_variants = filter_variants_by_transcripts(variants, filter_func)
        if filtered_variants:
            filtered_position = deepcopy(position)
            filtered_position[&#34;variants&#34;] = filtered_variants
            filtered_positions.append(filtered_position)
    return filtered_positions


def get_clinvar(variant):
    &#34;&#34;&#34;Get a table of all ClinVar annotations for a variant.

    Args:
        variant: the variant to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    if &#34;clinvar&#34; not in variant:
        return pd.DataFrame()
    return pd.DataFrame(variant[&#34;clinvar&#34;])


def get_biotype_priority(biotype):
    &#34;&#34;&#34;Get the numeric priority of a biotype.

    The numeric priority of a biotype that is returned by this function
    is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.
    Biotypes are &#39;protein_coding&#39;, &#39;LRG_gene&#39;, ,&#39;miRNA&#39;, ...

    Args:
        biotype: a string with a single biotype

    Returns:
        An integer, smaller values mean higher priority

    &#34;&#34;&#34;
    lowest_prio = max(_BIOTYPE_PRIORITY.values())
    if biotype not in _BIOTYPE_PRIORITY.keys():
        warnings.warn(
            &#39;&#34;&#39;
            + biotype
            + &#39;&#34; is not a known biotype and will be set to the lowest priority of &#39;
            + str(lowest_prio)
            + &#34;.&#34;
        )
    return _BIOTYPE_PRIORITY.get(biotype, lowest_prio)


def get_consequences(transcript):
    &#34;&#34;&#34;Get a list of consequences for a transcript

    A list of consequences for a transcript is returned. If any of the annotated
    consequences is a combination if single consequences, separated by
    ampersands (&#39;&amp;&#39;) or commas, such a consequence is split into single consequences.

    Args:
        transcript: the transcript to get the consequences for

    Returns:
        A list of strings
    &#34;&#34;&#34;
    consequences = transcript.get(&#34;consequence&#34;, [])
    consequences = [x for c in consequences for x in re.split(&#34;&amp;,&#34;, c)]
    return consequences


def get_vep_rank_for_consequence(consequence):
    &#34;&#34;&#34;Get the numeric rank of a VEP consequence term.

    The numeric rank of a consequence that is the position of the consequence
    in this list of consequences at https://www.ensembl.org/info/genome/variation/prediction/predicted_data.html

    Args:
        consequence: the consequence term of the mutation

    Returns:
        An integer
    &#34;&#34;&#34;
    if consequence not in vep_csq.index:
        return vep_csq[&#34;rank&#34;].max() + 1
    return vep_csq.loc[consequence, &#34;rank&#34;]


def get_vep_priority_for_consequence(consequence):
    &#34;&#34;&#34;Get the numeric priority of a VEP consequence term.

      The numeric priority of a consequence that is returned by this function
      is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.

    Args:
          consequence: the consequence term of the mutation

      Returns:
          An integer
    &#34;&#34;&#34;
    if consequence not in vep_csq.index:
        return vep_csq[&#34;priority&#34;].max() + 1
    return vep_csq.loc[consequence, &#34;priority&#34;]


def get_vep_consequence_for_rank(rank):
    &#34;&#34;&#34;Get the VEP consequence term of a numeric rank.

    Args:
        rank: the numeric rank of the consequence term

    Returns:
        A string
    &#34;&#34;&#34;
    if rank &gt; vep_csq.shape[0]:
        return &#34;unknown&#34;
    else:
        return list(vep_csq[vep_csq[&#34;rank&#34;] == rank].index)[0]


def get_strongest_vep_consequence_rank(transcript):
    &#34;&#34;&#34;Get the strongest rank of VEP consequences for a transcript.

    Get the strongest numeric rank of all VEP consequences
    for a transcript. Smaller ranks mean stronger impact.

    The priority of consequences is taken into account first. So if
    two consequences have different priorities, the consequence with
    the higher priority (lower priority number) will be used, and the
    rank for this consequence will be returned. If there are multiple
    consequences with the same priority, the lowest (strongest) rank
    will be returned.

    For clarification: ranks are unique, i.e. all VEP consequences
    ordered as listed on the VEP documentation page get the row number
    of this table assigned as rank.

    However, several consequences can have the same priority (e.g., stop
    gained and frameshift have the same priority). Priorities are copied
    from vcf2maf.pl.

    Args:
        transcript: the transcript to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    if &#34;consequence&#34; not in transcript:
        return vep_csq[&#34;rank&#34;].max() + 1
    consequences = get_consequences(transcript)
    df = vep_csq.loc[consequences]
    strongest_prio = df.priority.min()
    min_rank = df[df.priority == strongest_prio][&#34;rank&#34;].min()
    return min_rank


def get_strongest_vep_consequence_priority(transcript):
    &#34;&#34;&#34;Get the strongest priority of VEP consequence for a transcript.

    Get the strongest numeric priority of all VEP consequences
    for a transcript. Smaller numeric priorities mean stronger impact.

    Args:
        transcript: the transcript to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    if &#34;consequence&#34; not in transcript:
        return vep_csq[&#34;priority&#34;].max() + 1
    consequences = get_consequences(transcript)
    min_prio = vep_csq.loc[consequences, &#34;priority&#34;].min()
    return min_prio


def get_strongest_vep_consequence_name(transcript):
    &#34;&#34;&#34;Get the name of the strongest VEP consequence for a transcript.

    Args:
        transcript: the transcript to investigate

    Returns:
        A string
    &#34;&#34;&#34;
    rank = get_strongest_vep_consequence_rank(transcript)
    return get_vep_consequence_for_rank(rank)


def get_gene_type(gene_symbol):
    &#34;&#34;&#34;Get the gene type (oncogene, tsg, mixed) for a gene.

    Args:
        gene_symbol: the gene symbol of the gene

    Returns:
        a string
    &#34;&#34;&#34;
    if gene_symbol in gene_type.index:
        return gene_type.loc[gene_symbol, &#34;gene_type&#34;]
    else:
        return &#34;&#34;


def get_mutation_table_for_position(position):
    &#34;&#34;&#34;Get an annotated table of all transcripts.

    Returns an annotated table of all transcripts that are affected
    by a mutation at a position.

    Args:
        position: the position to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    vep_csq_categories = list(vep_csq.index)
    vep_csq_categories.reverse()
    df = pd.DataFrame()
    for variant_idx, variant in enumerate(position[&#34;variants&#34;]):
        # Get the variant frequency for this variant
        variant_frequencies = position[&#34;samples&#34;][0].get(&#34;variantFrequencies&#34;, [])
        if variant_idx &lt; len(variant_frequencies):
            variant_frequency = variant_frequencies[variant_idx]
        else:
            variant_frequency = np.nan
        # Create the table rows
        for transcript in variant[&#34;transcripts&#34;]:
            row = pd.DataFrame.from_dict(
                {
                    &#34;sample&#34;: [position[&#34;samples&#34;][0][&#34;sampleId&#34;]],
                    &#34;chromosome&#34;: [position[&#34;chromosome&#34;]],
                    &#34;position&#34;: [position[&#34;position&#34;]],
                    &#34;genotype&#34;: [position.get(&#34;samples&#34;)[0].get(&#34;genotype&#34;)],
                    &#34;variantFrequency&#34;: [variant_frequency],
                    &#34;hgnc&#34;: [transcript.get(&#34;hgnc&#34;, &#34;&#34;)],
                    &#34;source&#34;: [transcript.get(&#34;source&#34;, &#34;&#34;)],
                    &#34;geneId&#34;: [transcript.get(&#34;geneId&#34;, &#34;&#34;)],
                    &#34;transcriptId&#34;: [transcript.get(&#34;transcript&#34;, &#34;&#34;)],
                    &#34;proteinId&#34;: [transcript.get(&#34;proteinId&#34;, &#34;&#34;)],
                    &#34;hgvsg&#34;: [variant.get(&#34;hgvsg&#34;, &#34;&#34;)],
                    &#34;hgvsc&#34;: [transcript.get(&#34;hgvsc&#34;, &#34;&#34;)],
                    &#34;hgvsp&#34;: [transcript.get(&#34;hgvsp&#34;, &#34;&#34;)],
                    &#34;isCanonical&#34;: [transcript.get(&#34;isCanonical&#34;, False)],
                    &#34;vid&#34;: [variant[&#34;vid&#34;]],
                    &#34;begin&#34;: [variant[&#34;begin&#34;]],
                    &#34;end&#34;: [variant[&#34;end&#34;]],
                    &#34;refAllele&#34;: [variant[&#34;refAllele&#34;]],
                    &#34;altAllele&#34;: [variant[&#34;altAllele&#34;]],
                    &#34;variantType&#34;: [variant[&#34;variantType&#34;]],
                    &#34;bioType&#34;: [transcript.get(&#34;bioType&#34;, &#34;&#34;)],
                    &#34;geneType&#34;: [transcript.get(&#34;geneType&#34;, &#34;&#34;)],
                    &#34;mutationStatus&#34;: [transcript.get(&#34;mutationStatus&#34;, &#34;&#34;)],
                    &#34;codons&#34;: [transcript.get(&#34;codons&#34;, &#34;&#34;)],
                    &#34;aminoAcids&#34;: [transcript.get(&#34;aminoAcids&#34;, &#34;&#34;)],
                    &#34;cdnaPos&#34;: [transcript.get(&#34;cdnaPos&#34;, &#34;&#34;)],
                    &#34;cdsPos&#34;: [transcript.get(&#34;cdsPos&#34;, &#34;&#34;)],
                    &#34;exons&#34;: [transcript.get(&#34;exons&#34;, &#34;&#34;)],
                    &#34;proteinPos&#34;: [transcript.get(&#34;proteinPos&#34;, &#34;&#34;)],
                    &#34;consequence&#34;: [transcript.get(&#34;consequence&#34;, [])],
                    &#34;cosmicSampleCount&#34;: [get_cosmic_max_sample_count(variant)],
                    &#34;cosmicGeneTier&#34;: [get_cosmic_cancer_gene_census_tier(variant)],
                    &#34;maxGnomadAf&#34;: [get_gnomad_max_af(variant)],
                    &#34;maxGnomadExomeAf&#34;: [get_gnomad_exome_max_af(variant)],
                    &#34;maxOneKG&#34;: [get_onekg_max_af(variant)],
                }
            )
            df = pd.concat([df, row], ignore_index=True)
    return df


def get_mutation_table_for_positions(positions, hide_progress=False):
    &#34;&#34;&#34;Get an annotated table of all transcripts for all positions.

    Returns an annotated table of all transcripts that are affected
    by a mutation at any of the position.

    Args:
        positions: the positions to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;

    if len(positions) == 0:
        return pd.DataFrame()
    mutation_tables = []
    for p in tqdm(positions, disable=hide_progress, desc=&#34;Positions&#34;):
        mutation_tables.append(get_mutation_table_for_position(p))
    if len(mutation_tables) == 0:
        return pd.DataFrame()
    mutation_table = pd.concat(mutation_tables, ignore_index=True)
    return mutation_table


def _get_mutation_table_for_single_file(
    file,
    max_af=0.01,
    min_vep_consequence_priority=6,
    min_cosmic_sample_count=0,
    only_canonical=False,
    extra_variant_filters=[],
    extra_transcript_filters=[],
):
    &#34;&#34;&#34;Get an annotated table of all filtered transcripts from a ICA JSON file.

    Load all positions from a ICA JSON file and filter them. Positions having
    any remaining variants and transcripts passing the filter are returned as an
    annotated table.

    Args:
        file:   a ICA JSON file
        max_af: maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.
                Only variants with maximum allele frequencies below this threshold
                will be returned.
        min_vep_consequence_priority: only transcripts with a minimum VEP
                consequence priority not larger than this threshold will be retained
        min_cosmic_sample_count: only variants with a maximum cosmic sample count
                not lower than this threshold will be retained
        only_canonical: if true, only canonical transcripts will be retained
        extra_variant_filters: any additional filters to apply to variants.
                Filters shall return True to keep a variant.
        extra_transcript_filters: any additional filters to apply to transcripts.
                Filters shall return True to keep a transcript.

    Returns:
        A pandas.DataFrame

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; extra_transcript_filters = [
                lambda x: x.get(&#39;source&#39;, &#39;&#39;) == &#39;Ensembl&#39;,
                lambda x: x.get(&#39;hgnc&#39;, &#39;&#39;) == &#39;KRAS&#39;
            ]
        &gt;&gt;&gt; df = pd.concat([
                     icap.get_mutation_table_for_single_file(
                         x, extra_transcript_filters=extra_transcript_filters
                     )
                for x in json_files],
               ignore_index=True)
        &gt;&gt;&gt; df
    &#34;&#34;&#34;
    # Get all positions from the json file
    positions = get_positions(file)
    # For performance reasons, we apply the extra filters first. They may, for example,
    # look for only single genes.
    # Apply extra variant filters
    for vf in extra_variant_filters:
        positions = filter_positions_by_variants(positions, vf)
    # Apply extra transcript filters
    for tf in extra_transcript_filters:
        positions = filter_positions_by_transcripts(positions, tf)
    # Keep only non-common variants
    positions = filter_positions_by_variants(
        positions,
        lambda x: (
            get_gnomad_max_af(x) &lt;= max_af
            and get_gnomad_exome_max_af(x) &lt;= max_af
            and get_onekg_max_af(x) &lt;= max_af
        ),
    )
    # Keep only variants with high enough cosmic sample count
    positions = filter_positions_by_variants(
        positions, lambda x: get_cosmic_max_sample_count(x) &gt;= min_cosmic_sample_count
    )
    # Keep only protein coding variants
    positions = filter_positions_by_transcripts(
        positions, lambda x: x.get(&#34;bioType&#34;, &#34;&#34;) == &#34;protein_coding&#34;
    )
    # Keep only variants with high enough VEP impact
    positions = filter_positions_by_transcripts(
        positions,
        lambda x: get_strongest_vep_consequence_priority(x)
        &lt;= min_vep_consequence_priority,
    )
    # Keep only canonical transcripts if requested
    if only_canonical:
        positions = filter_positions_by_transcripts(
            positions, lambda x: x.get(&#34;isCanonical&#34;, False)
        )
    # Get the transcript table
    mutation_table = get_mutation_table_for_positions(positions, hide_progress=True)
    # Done
    return mutation_table


def get_mutation_table_for_files(
    json_files,
    max_af=0.01,
    min_vep_consequence_priority=6,
    min_cosmic_sample_count=0,
    only_canonical=False,
    extra_variant_filters=[],
    extra_transcript_filters=[],
):
    &#34;&#34;&#34;Get an annotated table of all filtered transcripts from a list of ICA JSON files.

    Load all positions from a list of ICA JSON files and filter them.
    Positions having any remaining variants and transcripts passing the filter
    are returned as an annotated table.

    Args:
        files:  list of ICA JSON files
        max_af: maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.
                Only variants with maximum allele frequencies below this threshold
                will be returned.
        min_vep_consequence_priority: only transcripts with a minimum VEP
                consequence priority not larger than this threshold will be retained
        min_cosmic_sample_count: only variants with a maximum cosmic sample count
                not lower than this threshold will be retained
        only_canonical: if true, only canonical transcripts will be retained
        extra_variant_filters: any additional filters to apply to variants.
                Filters shall return True to keep a variant.
        extra_transcript_filters: any additional filters to apply to transcripts.
                Filters shall return True to keep a transcript.

    Returns:
        A pandas.DataFrame

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; extra_transcript_filters = [
                lambda x: x.get(&#39;source&#39;, &#39;&#39;) == &#39;Ensembl&#39;,
                lambda x: x.get(&#39;hgnc&#39;, &#39;&#39;) == &#39;KRAS&#39;
            ]
        &gt;&gt;&gt; mut_table = icap.get_mutation_table_for_files(
                json_files,
                extra_transcript_filters=extra_transcript_filters
            )
    &#34;&#34;&#34;
    df = pd.concat(
        [
            _get_mutation_table_for_single_file(
                x,
                max_af=max_af,
                min_vep_consequence_priority=min_vep_consequence_priority,
                min_cosmic_sample_count=min_cosmic_sample_count,
                only_canonical=only_canonical,
                extra_variant_filters=extra_variant_filters,
                extra_transcript_filters=extra_transcript_filters,
            )
            for x in tqdm(json_files)
        ],
        ignore_index=True,
    )
    # If none of the positions passes the filters, return the empty dataframe.
    # For an empty dataframe, the rest of this function would fail because the
    # empty dataframe does not contain these columns.
    if df.empty:
        return df
    # Make chromosome a categorical veriable set sorting order
    df[&#34;chromosome&#34;] = df[&#34;chromosome&#34;].astype(&#34;category&#34;)
    df[&#34;chromosome&#34;] = df[&#34;chromosome&#34;].cat.reorder_categories(
        natsorted(df[&#34;chromosome&#34;].cat.categories), ordered=True
    )
    # Make isCanonical an ordered categorical variable
    df[&#34;isCanonical&#34;] = pd.Categorical(df[&#34;isCanonical&#34;], ordered=True)
    return df


def explode_consequence(mutation_table, inplace=False):
    &#34;&#34;&#34;Explode the VEP consequence column of a mutation table.

    Exploding the VEP consequence column with the standard Pandas
    `explode()` function would return consquences as strings, not as
    ordered categories. This function will instead return a consequence
    columns which is an ordered category. The categories are ordered by
    their impact.

    Args:
        mutation_table: the mutation table to explode
        inplace: if True, then modify the mutation_table in place instead
            of returning a new object

    Returns:
        A pandas.DataFrame

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.explode_consequence(mutation_table, inplace=True)

        &gt;&gt;&gt; mutation_table_exploded = icap.explode_consequence(mutation_table)
    &#34;&#34;&#34;
    vep_csq_cats = list(vep_csq.index)
    vep_csq_cats.reverse()
    if not inplace:
        mutation_table = deepcopy(mutation_table)
    mutation_table = mutation_table.explode(column=&#34;consequence&#34;)
    mutation_table[&#34;consequence&#34;] = pd.Categorical(
        mutation_table[&#34;consequence&#34;], categories=vep_csq_cats, ordered=True
    )
    return mutation_table


def add_gene_types(positions):
    &#34;&#34;&#34;Adds the gene type to each transcript.

    Transcripts will be annotated with the gene type (*oncogene*, *tsg*,
    *mixed*) by adding a new attribute `geneType`. Only transcripts with
    one of these three gene types get this additional annotation. Other
    transcripts will not get the `geneType` attribute.

    Args:
        positions: list of filtered or unfiltered positions from JSON files

    Returns:
        A list of positions with additional annotation of transcripts

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions = icap.add_gene_types(positions)
    &#34;&#34;&#34;
    for position in positions:
        for variant in position.get(&#34;variants&#34;, []):
            for transcript in variant.get(&#34;transcripts&#34;, []):
                gene = transcript.get(&#34;hgnc&#34;, &#34;&#34;)
                gene_type = get_gene_type(gene)
                if gene_type != &#34;&#34;:
                    transcript[&#34;geneType&#34;] = gene_type
    return positions


def get_default_gene_type_map():
    &#34;&#34;&#34;Returns the default gene type map.

    The canonical gene types are `gof`, `lof`, and the union of both.
    Genes that need to be activated to drive a tumor are of type `gof`.
    Genes that need to be deactivated to drive a tumor are of type `lof`.
    Genes that need to be activated or deactivated depending on the context
    are of the union of both types.
    Genes for which it is unknown if they need to be activated or deactivated
    are also annotated with both types.
    Genes can be originally annotated with other type names than the canonical
    ones. The gene type map is used to map these other gene type names to the
    canonical gene types.

    The default map is:

    - `oncogene` → `{&#34;gof&#34;}`
    - `tsg` → `{&#34;lof&#34;}`
    - `Act` → `{&#34;gof&#34;}`
    - `LoF` → `{&#34;lof&#34;}`
    - `mixed` → `{&#34;gof&#34;, &#34;lof&#34;}`
    - `ambiguous` → `{&#34;gof&#34;, &#34;lof&#34;}`

    Returns:
        A dictionary with mappings from gene types to canonical gene types

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_gene_type_map()

    &#34;&#34;&#34;
    # Define some mappings of gene types to rule set keys
    gene_type_map = {
        &#34;oncogene&#34;: {&#34;gof&#34;},
        &#34;tsg&#34;: {&#34;lof&#34;},
        &#34;mixed&#34;: {&#34;gof&#34;, &#34;lof&#34;},
        &#34;Act&#34;: {&#34;gof&#34;},
        &#34;LoF&#34;: {&#34;lof&#34;},
        &#34;ambiguous&#34;: {&#34;gof&#34;, &#34;lof&#34;},
        &#34;&#34;: {&#34;gof&#34;, &#34;lof&#34;},
    }
    return gene_type_map


def get_default_mutation_classification_rules(cosmic_threshold=10):
    &#34;&#34;&#34;Returns the default rules for classifying mutations.

    Defines the default rules for classifying mutations. The returned dictonary
    has keys &#34;gof&#34; and &#34;lof&#34;, and the respective values are the rule sets for
    these gene types. A rule set is again a dictionary with the keys &#34;mutated&#34;
    and &#34;uncertain&#34;. The values for &#34;mutated&#34; or &#34;uncertain&#34; are dictionaries
    with three filter functions, a &#34;position_filter&#34;, a &#34;variant_filter&#34;, and
    a &#34;transcript filter&#34;. For example, a transcript will be called &#34;mutated&#34;
    if all three filters for &#34;mutated&#34; return True, and it will be called
    &#34;uncertain&#34;, if all three filter functions for &#34;uncertain&#34; return True.

    Args:
        cosmic_threshold: for &#34;gof&#34; genes, this is the &#34;hotspot threshold&#34; for
            Cosmic, i.e., the minimum number of samples in Cosmic having that
            mutation to consider a mutation a hot spot and, therefore, call the
            mutation &#34;mutated&#34;. If the number of Cosmic samples is smaller, the
            mutation is called &#34;uncertain&#34;.

    Returns:
        A dictionary with mutation classification rules

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_mutation_classification_rules()
        &gt;&gt;&gt; icap.get_default_mutation_classification_rules(cosmic_threshold=20)

    &#34;&#34;&#34;
    classification_rules = {
        &#34;gof&#34;: {
            # potentially activating mutations (inframe indels, missense mutations)
            # that are hotspots. Currently, hotspots are defined by Cosmic only.
            &#34;mutated&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: (
                    get_cosmic_max_sample_count(v) &gt;= cosmic_threshold
                ),
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
            # potentially activating mutations (inframe indels, missense mutations)
            # that are not hotspots
            &#34;uncertain&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: (
                    get_cosmic_max_sample_count(v) &lt; cosmic_threshold
                ),
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
        },
        &#34;lof&#34;: {
            # disruptive mutations (transcript_ablation, splice_acceptor_variant,
            # splice_donor_variant, stop_gained, stop_lost, start_lost,
            # frameshift_variant)
            &#34;mutated&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: True,
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &lt;= 4
                ),
            },
            # potentially disruptive mutations (inframe indels, missense mutations)
            &#34;uncertain&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: True,
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
        },
    }
    return classification_rules


def apply_mutation_classification_rules(
    positions,
    rule_set=get_default_mutation_classification_rules(),
    gene_type_map=get_default_gene_type_map(),
    hide_progress=False,
):
    &#34;&#34;&#34;Applies mutation classification rules to all positions.

    Each mutation is categorized for each isoform that overlaps with the genomic
    position of the mutation. Each transcript which passed the &#34;mutated&#34; or
    &#34;uncertain&#34; rule of the classification rules gets a new attribute
    `mutation_status` with the value &#34;mutated&#34; or &#34;uncertain&#34;.

    In addition to classifying mutations based on their impact on transcript
    isoforms, this function also assembles the mutation status on sample and
    gene level without further aggregation. The impact depends on the type of
    gene (&#34;gof&#34; or &#34;lof&#34;), so the impacts are assembled separately for each gene
    type:

    `sample_id` → `gene` → `gene_type` → `variant_id` → `mutationStatus`

    The impact of a particular mutational variant can be different for different
    overlapping transcript variants of a gene, and the transcript variants can
    also belong to different genes. The strongest impact on any overlapping
    transcript of a gene is defined as the impact of that mutational
    variant on the gene. The analyst must decide which isoforms are used to
    classify genes. For example, only canonical transcripts may be considered.
    Alternatively, all transcripts or a subset of transcripts may be used.
    Therefore, it is necessary to first apply transcript-level filters to all
    genomic positions  before determining the mutation status of genes.

    Args:
        positions: list of positions
        rule_set: rules for classifying &#34;gof&#34; and &#34;lof&#34; genes. See also
            `get_default_mutation_classification_rules()` for an example
            if the default rule set needs to be modified.
        gene_type_map: dictionary for mapping gene types to canonical gene
            types. See also `get_default_gene_type_map()` for an example
            if the default mapping table needs to be modified.

    Returns:
        A list of positions and a dictionary with assembled and aggregated
        mutations

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions, sample_muts = icap.apply_mutation_classification_rules(positions)
    &#34;&#34;&#34;
    sample_muts = {}
    mut_rank = {&#34;mutated&#34;: 0, &#34;uncertain&#34;: 1, &#34;not_mutated&#34;: 2, &#34;&#34;: 3}
    for gene_type, rules in tqdm(
        rule_set.items(), disable=hide_progress, desc=&#34;Level 1: Gene type&#34;
    ):
        for mut_status, filters in tqdm(
            rules.items(), disable=hide_progress, desc=&#34;Level 2: Mutation status&#34;
        ):
            for p in tqdm(positions, disable=hide_progress, desc=&#34;Level 3: Positions&#34;):
                if not filters[&#34;position_filter&#34;](p):
                    continue
                sample_ids = [x[&#34;sampleId&#34;] for x in p[&#34;samples&#34;]]
                for v in p.get(&#34;variants&#34;, []):
                    if not filters[&#34;variant_filter&#34;](v):
                        continue
                    for t in v.get(&#34;transcripts&#34;, []):
                        if not filters[&#34;transcript_filter&#34;](t):
                            continue
                        # Get the gene symbol
                        gene = t.get(&#34;hgnc&#34;, &#34;&#34;)
                        # Get the gene type of the current transcript or set it to ambiguous
                        # if the transcript has no gene type annotation
                        this_gene_type = t.get(&#34;geneType&#34;, &#34;ambiguous&#34;)
                        # Map the gene type to {&#39;gof&#39;}, {&#39;lof&#39;} or {&#39;gof&#39;, &#39;lof&#39;}
                        this_gene_type = gene_type_map.get(
                            this_gene_type, {&#34;gof&#34;, &#34;lof&#34;}
                        )
                        # Skip this transcript if the gene type for the current rule is not within
                        # the gene types of the current transcript
                        if gene_type not in this_gene_type:
                            continue
                        current_mut_status = t.get(&#34;mutationStatus&#34;, &#34;&#34;)
                        if mut_rank[mut_status] &lt;= mut_rank[current_mut_status]:
                            t[&#34;mutationStatus&#34;] = mut_status
                        for sample_id in sample_ids:
                            this_sample_muts = sample_muts.get(sample_id, {})
                            this_gene_muts = this_sample_muts.get(gene, {})
                            this_gene_type_mut_status = this_gene_muts.get(
                                gene_type, {}
                            )
                            this_variant_mut_status = this_gene_type_mut_status.get(
                                v[&#34;vid&#34;], &#34;&#34;
                            )
                            if (
                                mut_rank[mut_status]
                                &lt;= mut_rank[this_variant_mut_status]
                            ):
                                this_variant_mut_status = mut_status
                            this_gene_type_mut_status[
                                v[&#34;vid&#34;]
                            ] = this_variant_mut_status
                            this_gene_muts[gene_type] = this_gene_type_mut_status
                            this_sample_muts[gene] = this_gene_muts
                            sample_muts[sample_id] = this_sample_muts
    return positions, sample_muts


def get_default_mutation_aggregation_rules():
    &#34;&#34;&#34;Returns the default mutation aggregation rules.

    Two types of the mutation status of a gene are introduced - allele level and
    gene level:

    - For &#34;gof&#34; genes (like oncogenes) it is sufficient if one of the alleles of
        one of the relevant isoforms has an activating mutation.
    - For &#34;lof&#34; genes (like tumor suppressor genes) all alleles of all relevant
        isoforms need to be functionally disrupted, either by mutations or by
        other means.
    - For Mixed and Other genes, the impact of a mutation is defined as the
        highest impact according to &#34;gof&#34; rules and &#34;lof&#34; rules.

    For &#34;gof&#34; genes, the allele and gene level classifications are identical
    unless there is additional information about activating modifications other
    than mutations. For &#34;lof&#34; genes, allele and gene level classifications
    may be different. For example, a truncating mutation of a tumor suppressor
    gene is functionally disruptive for the affected allele. However, there may
    be other functionally active alleles of the same gene, i.e., the gene itself
    may still be active. All alleles of such a gene must be dysfunctional,
    either by additional mutations or by other processes, such as copy number
    deletions or hypermethylation. Therefore, a single variant that is
    disruptive at the allele level is not necessarily also disruptive at the
    gene level. For &#34;lof&#34; genes, we usually do not have enough information
    for a reliable estimation of functional effects. Instead, some heuristic
    ules must be applied, and the analyst must decide whether to work with
    allele-level or gene-level classifications. We designate a &#34;lof&#34; gene as
    functionally disrupted (strong impact) if it has at least two mutations with
    either strong impact or uncertain impact. If a &#34;lof&#34; gene has only one of
    these mutations, it is designated as uncertain impact at the gene level,
    even if one of these mutations has a strong impact at the allele level. By
    categorizing effects at both allele and gene levels, we retain the
    flexibility to decide in downstream analyses how to merge some of these
    categories for subsequent statistical calculations.

    Additional filters based on publications, white lists and black lists for
    mutations can be applied. These are not part of the first version and will
    be added later. White and black lists can be based, for example, on ClinVar
    and on the publication by Hess et al. (2019).

    Returns:
        A dictionary

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_mutation_aggregation_rules()
    &#34;&#34;&#34;

    def _aggregation_rules_gof(mut_counts):
        if mut_counts.get(&#34;mutated&#34;, 0) &gt;= 1:
            allele_level = gene_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 1:
            allele_level = gene_level = &#34;uncertain&#34;
        else:
            allele_level = gene_level = &#34;not_mutated&#34;
        return allele_level, gene_level

    def _aggregation_rules_lof(mut_counts):
        # allele level
        if mut_counts.get(&#34;mutated&#34;, 0) &gt;= 1:
            allele_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 1:
            allele_level = &#34;uncertain&#34;
        else:
            allele_level = &#34;not_mutated&#34;
        # gene level
        if mut_counts.get(&#34;mutated&#34;, 0) + mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 2:
            gene_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;mutated&#34;, 0) + mut_counts.get(&#34;uncertain&#34;, 0) == 1:
            gene_level = &#34;uncertain&#34;
        else:
            gene_level = &#34;not_mutated&#34;
        return allele_level, gene_level

    mutation_aggregation_rules = {
        &#34;gof&#34;: _aggregation_rules_gof,
        &#34;lof&#34;: _aggregation_rules_lof,
    }

    return mutation_aggregation_rules


def get_aggregated_mutation_table(
    positions,
    mutation_classification_rules=get_default_mutation_classification_rules(),
    mutation_aggregation_rules=get_default_mutation_aggregation_rules(),
    gene_type_map=get_default_gene_type_map(),
    hide_progress=False,
):
    &#34;&#34;&#34;Returns a sample-gene-mutationStatus table.

    This function applies mutation classification rules to all mutational
    variants and aggregates the mutations according to the aggregation rules.
    This results in a table with one row for each sample-gene pair. The table
    contains several columns with impacts for &#34;lof&#34; and &#34;gof&#34; on allele level
    and gene level and with one additional column with the maximum impact for
    both allele and gene level.

    Args:
        positions: list of positions
        mutation_classification_rules: rules for classifying single mutations.
            See `get_default_mutation_classification_rules()` for details.
        mutation_aggregation_rules: rules for aggregation mutations.
            See `get_default_mutation_aggregation_reles()` for details.
        gene_type_map: dictonary for mapping gene types to canonical gene types.
            See `get_default_gene_type_map()` for details.

    Returns:
        A pandas.DataFrame with the mutation table.
    &#34;&#34;&#34;
    gene_type_cache = {}
    for p in positions:
        for v in p.get(&#34;variants&#34;, []):
            for t in v.get(&#34;transcripts&#34;, []):
                gene_type_cache[t.get(&#34;hgnc&#34;, &#34;&#34;)] = t.get(&#34;geneType&#34;, &#34;&#34;)

    def get_max_mut_status(mut_status):
        if &#34;mutated&#34; in mut_status:
            return &#34;mutated&#34;
        elif &#34;uncertain&#34; in mut_status:
            return &#34;uncertain&#34;
        else:
            return &#34;not_mutated&#34;

    p, sample_muts = apply_mutation_classification_rules(
        positions,
        rule_set=mutation_classification_rules,
        gene_type_map=gene_type_map,
        hide_progress=hide_progress,
    )
    agg_mutation_table = pd.DataFrame()
    for sample_id, gene_muts in tqdm(
        sample_muts.items(), disable=hide_progress, desc=&#34;Samples&#34;
    ):
        for gene, gene_type_muts in gene_muts.items():
            gene_mut_counts = {}
            for gene_type, variant_muts in gene_type_muts.items():
                gene_type_mut_counts = gene_mut_counts.get(gene_type, {})
                for vid, mut_status in variant_muts.items():
                    mut_counts = gene_type_mut_counts.get(mut_status, 0)
                    mut_counts += 1
                    gene_type_mut_counts[mut_status] = mut_counts
                gene_mut_counts[gene_type] = gene_type_mut_counts
            gene_type = gene_type_cache.get(gene)
            canonical_gene_type = gene_type_map[gene_type]
            gof_allele_status = (
                mutation_aggregation_rules[&#34;gof&#34;](gene_mut_counts[&#34;gof&#34;])[0]
                if &#34;gof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            lof_allele_status = (
                mutation_aggregation_rules[&#34;lof&#34;](gene_mut_counts[&#34;lof&#34;])[0]
                if &#34;lof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            gof_gene_status = (
                mutation_aggregation_rules[&#34;gof&#34;](gene_mut_counts[&#34;gof&#34;])[1]
                if &#34;gof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            lof_gene_status = (
                mutation_aggregation_rules[&#34;lof&#34;](gene_mut_counts[&#34;lof&#34;])[1]
                if &#34;lof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            row = pd.DataFrame.from_dict(
                {
                    &#34;sample_id&#34;: [sample_id],
                    &#34;gene&#34;: [gene],
                    &#34;geneType&#34;: [gene_type],
                    &#34;canonicalGeneType&#34;: [canonical_gene_type],
                    &#34;gof_mutated_count&#34;: [
                        gene_mut_counts.get(&#34;gof&#34;, {}).get(&#34;mutated&#34;, 0)
                        if ({&#34;gof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;gof_uncertain_count&#34;: [
                        gene_mut_counts.get(&#34;gof&#34;, {}).get(&#34;uncertain&#34;, 0)
                        if ({&#34;gof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;lof_mutated_count&#34;: [
                        gene_mut_counts.get(&#34;lof&#34;, {}).get(&#34;mutated&#34;, 0)
                        if ({&#34;lof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;lof_uncertain_count&#34;: [
                        gene_mut_counts.get(&#34;lof&#34;, {}).get(&#34;uncertain&#34;, 0)
                        if ({&#34;lof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;gof_allele_status&#34;: [gof_allele_status],
                    &#34;lof_allele_status&#34;: [lof_allele_status],
                    &#34;gof_gene_status&#34;: [gof_gene_status],
                    &#34;lof_gene_status&#34;: [lof_gene_status],
                    &#34;allele_status&#34;: [
                        get_max_mut_status((gof_allele_status, lof_allele_status))
                    ],
                    &#34;gene_status&#34;: [
                        get_max_mut_status((gof_gene_status, lof_gene_status))
                    ],
                    &#34;gene_or_allele_status&#34;: [
                        get_max_mut_status(
                            (
                                gof_allele_status,
                                lof_allele_status,
                                gof_gene_status,
                                lof_gene_status,
                            )
                        )
                    ],
                }
            )
            agg_mutation_table = pd.concat([agg_mutation_table, row], ignore_index=True)
    count_cols = [x for x in agg_mutation_table.columns if &#34;count&#34; in x]
    for col in count_cols:
        agg_mutation_table[col] = agg_mutation_table[col].astype(pd.Int64Dtype())
    return agg_mutation_table


def split_multi_sample_json_file(json_file, output_dir):
    &#34;&#34;&#34;Splits a multi-sample JSON file into sample specifc JSON files.

    This function reads a multi-sample JSON file that was generated by
    annotating a multi-sample VCF file with ICA and splits it into
    sample-specific JSON files.

    Annotating very many single-sample VCF files with ICA is very time
    consuming, because ICA reads all annotation sources for each VCF file
    and this is dominating the runtime of ICA. It is therefore helpful to
    first merge many single-sample VCF files into one or a small number of
    multi-sample VCF files (for example, with `bcftools merge`), to annotate
    the multi-sample VCF file with ICA, and then to split the multi-sample
    JSON output of ICA into single-sample JSON files. These single-sample
    JSON files are required for the rest of this package.

    Args:
        json_file: the multi-sample json input file
        output_dir: the directory where to write the single sample JSON files.
            The directory will be created if it does not exist.

    Returns:
        Nothing
    &#34;&#34;&#34;
    os.makedirs(output_dir, exist_ok=True)
    is_header_line = True
    is_position_line = False
    is_first_position_line = {}
    is_gene_line = False
    is_first_gene_line = {}
    header_end = &#39;,&#34;positions&#34;:[&#39;
    gene_section_line = &#39;],&#34;genes&#34;:[&#39;
    end_line = &#34;]}&#34;
    ofiles = {}
    genes = {}
    with gzip.open(json_file, &#34;rt&#34;) as fin:
        for line in fin:
            trim_line = line.strip()
            if is_header_line:
                is_header_line = False
                is_position_line = True
                header_json = trim_line[: -len(header_end)] + &#34;}&#34;
                header = json.loads(header_json)[&#34;header&#34;]
                samples = header[&#34;samples&#34;]
                for sample in samples:
                    is_first_position_line[sample] = True
                    s_header = header.copy()
                    s_header[&#34;samples&#34;] = [sample]
                    s_header_json = json.dumps(
                        {&#34;header&#34;: s_header}, separators=(&#34;,&#34;, &#34;:&#34;)
                    )
                    s_header_line = s_header_json[:-1] + header_end
                    s_fname = os.path.join(output_dir, sample + &#34;.json.gz&#34;)
                    ofiles[sample] = gzip.open(s_fname, &#34;wt&#34;)
                    print(s_header_line, file=ofiles[sample])
                continue
            if trim_line == gene_section_line:
                is_position_line = False
                is_gene_line = True
                for sample in samples:
                    is_first_gene_line[sample] = True
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=ofiles[sample])
                continue
            elif trim_line == end_line:
                for sample in samples:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=ofiles[sample])
                break
            else:
                if is_position_line:
                    ## remove the training &#39;,&#39; if there is
                    position_json = trim_line.rstrip(&#34;,&#34;)
                    position = json.loads(position_json)
                    p_samples = position[&#34;samples&#34;]
                    for sample_idx, sample in enumerate(samples):
                        p_sample = p_samples[sample_idx].copy()
                        # Continue if this sample is not mutated here
                        if p_sample[&#34;genotype&#34;] in (&#34;0/0&#34;, &#34;./.&#34;):
                            continue
                        # Get the variant indeces for this sample
                        variant_idxs = p_sample[&#34;genotype&#34;]
                        variant_idxs = variant_idxs.split(&#34;/&#34;)
                        variant_idxs = set(variant_idxs) - set(&#34;0&#34;)
                        variant_idxs = map(lambda x: int(x) - 1, list(variant_idxs))
                        variant_idxs = sorted(variant_idxs)
                        # Get the new genotype name for this sample
                        s_gt = p_sample[&#34;genotype&#34;]
                        s_gt = s_gt.split(&#34;/&#34;)
                        s_gt = [
                            int(x) - min(variant_idxs) if x != &#34;0&#34; else 0 for x in s_gt
                        ]
                        s_gt = &#34;/&#34;.join(map(str, s_gt))
                        p_sample[&#34;genotype&#34;] = s_gt
                        # Adjust the list of variantFrequencies
                        if len(p_sample.get(&#34;variantFrequencies&#34;, [])) &gt; 0:
                            p_sample[&#34;variantFrequencies&#34;] = [
                                p_sample[&#34;variantFrequencies&#34;][i] for i in variant_idxs
                            ]
                        else:
                            p_sample[&#34;variantFrequencies&#34;] = []
                        # Adjust the list of alleleDepths
                        if len(p_sample.get(&#34;alleleDepths&#34;, [])) &gt; 0:
                            p_sample[&#34;alleleDepths&#34;] = [p_sample[&#34;alleleDepths&#34;][0]] + [
                                p_sample[&#34;alleleDepths&#34;][i + 1] for i in variant_idxs
                            ]
                        else:
                            p_sample[&#34;alleleDepths&#34;] = []
                        # Keep only alleles relevant for this sample
                        s_position = position.copy()
                        s_position[&#34;samples&#34;] = [p_sample]
                        s_position[&#34;altAlleles&#34;] = [
                            s_position[&#34;altAlleles&#34;][i] for i in variant_idxs
                        ]
                        s_position[&#34;variants&#34;] = [
                            s_position[&#34;variants&#34;][i] for i in variant_idxs
                        ]
                        if is_first_position_line[sample]:
                            finish_prev_line = &#34;&#34;
                            genes[sample] = set()
                        else:
                            finish_prev_line = &#34;,\n&#34;
                        print(
                            finish_prev_line,
                            json.dumps(s_position, separators=(&#34;,&#34;, &#34;:&#34;)),
                            sep=&#34;&#34;,
                            end=&#34;&#34;,
                            file=ofiles[sample],
                        )
                        for variant in position.get(&#34;variants&#34;, []):
                            for transcript in variant.get(&#34;transcripts&#34;, []):
                                if &#34;hgnc&#34; in transcript:
                                    genes[sample].add(transcript[&#34;hgnc&#34;])
                        is_first_position_line[sample] = False
                if is_gene_line:
                    ## remove the trailing &#34;,&#34; if there is
                    gene_json = trim_line.rstrip(&#34;,&#34;)
                    gene = json.loads(gene_json)[&#34;name&#34;]
                    for sample_idx, sample in enumerate(samples):
                        if sample in genes and gene in genes[sample]:
                            if is_first_gene_line[sample]:
                                finish_prv_line = &#34;&#34;
                            else:
                                finish_prv_line = &#34;,\n&#34;
                            print(
                                finish_prv_line,
                                gene_json,
                                sep=&#34;&#34;,
                                end=&#34;&#34;,
                                file=ofiles[sample],
                            )
                            is_first_gene_line[sample] = False
    # Close the output files
    for ofile in ofiles.values():
        ofile.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="icaparser.add_gene_types"><code class="name flex">
<span>def <span class="ident">add_gene_types</span></span>(<span>positions)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the gene type to each transcript.</p>
<p>Transcripts will be annotated with the gene type (<em>oncogene</em>, <em>tsg</em>,
<em>mixed</em>) by adding a new attribute <code>geneType</code>. Only transcripts with
one of these three gene types get this additional annotation. Other
transcripts will not get the <code>geneType</code> attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of filtered or unfiltered positions from JSON files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>positions with additional annotation</code> of <code>transcripts</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; positions = icap.add_gene_types(positions)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_gene_types(positions):
    &#34;&#34;&#34;Adds the gene type to each transcript.

    Transcripts will be annotated with the gene type (*oncogene*, *tsg*,
    *mixed*) by adding a new attribute `geneType`. Only transcripts with
    one of these three gene types get this additional annotation. Other
    transcripts will not get the `geneType` attribute.

    Args:
        positions: list of filtered or unfiltered positions from JSON files

    Returns:
        A list of positions with additional annotation of transcripts

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions = icap.add_gene_types(positions)
    &#34;&#34;&#34;
    for position in positions:
        for variant in position.get(&#34;variants&#34;, []):
            for transcript in variant.get(&#34;transcripts&#34;, []):
                gene = transcript.get(&#34;hgnc&#34;, &#34;&#34;)
                gene_type = get_gene_type(gene)
                if gene_type != &#34;&#34;:
                    transcript[&#34;geneType&#34;] = gene_type
    return positions</code></pre>
</details>
</dd>
<dt id="icaparser.apply_mutation_classification_rules"><code class="name flex">
<span>def <span class="ident">apply_mutation_classification_rules</span></span>(<span>positions, rule_set={&#x27;gof&#x27;: {&#x27;mutated&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}, &#x27;uncertain&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}}, &#x27;lof&#x27;: {&#x27;mutated&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}, &#x27;uncertain&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}}}, gene_type_map={'oncogene': {'gof'}, 'tsg': {'lof'}, 'mixed': {'gof', 'lof'}, 'Act': {'gof'}, 'LoF': {'lof'}, 'ambiguous': {'gof', 'lof'}, '': {'gof', 'lof'}}, hide_progress=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies mutation classification rules to all positions.</p>
<p>Each mutation is categorized for each isoform that overlaps with the genomic
position of the mutation. Each transcript which passed the "mutated" or
"uncertain" rule of the classification rules gets a new attribute
<code>mutation_status</code> with the value "mutated" or "uncertain".</p>
<p>In addition to classifying mutations based on their impact on transcript
isoforms, this function also assembles the mutation status on sample and
gene level without further aggregation. The impact depends on the type of
gene ("gof" or "lof"), so the impacts are assembled separately for each gene
type:</p>
<p><code>sample_id</code> → <code>gene</code> → <code>gene_type</code> → <code>variant_id</code> → <code>mutationStatus</code></p>
<p>The impact of a particular mutational variant can be different for different
overlapping transcript variants of a gene, and the transcript variants can
also belong to different genes. The strongest impact on any overlapping
transcript of a gene is defined as the impact of that mutational
variant on the gene. The analyst must decide which isoforms are used to
classify genes. For example, only canonical transcripts may be considered.
Alternatively, all transcripts or a subset of transcripts may be used.
Therefore, it is necessary to first apply transcript-level filters to all
genomic positions
before determining the mutation status of genes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of positions</dd>
<dt><strong><code>rule_set</code></strong></dt>
<dd>rules for classifying "gof" and "lof" genes. See also
<code><a title="icaparser.get_default_mutation_classification_rules" href="#icaparser.get_default_mutation_classification_rules">get_default_mutation_classification_rules()</a></code> for an example
if the default rule set needs to be modified.</dd>
<dt><strong><code>gene_type_map</code></strong></dt>
<dd>dictionary for mapping gene types to canonical gene
types. See also <code><a title="icaparser.get_default_gene_type_map" href="#icaparser.get_default_gene_type_map">get_default_gene_type_map()</a></code> for an example
if the default mapping table needs to be modified.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>positions and a dictionary with assembled and aggregated</code></dt>
<dd>&nbsp;</dd>
<dt><code>mutations</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; positions, sample_muts = icap.apply_mutation_classification_rules(positions)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_mutation_classification_rules(
    positions,
    rule_set=get_default_mutation_classification_rules(),
    gene_type_map=get_default_gene_type_map(),
    hide_progress=False,
):
    &#34;&#34;&#34;Applies mutation classification rules to all positions.

    Each mutation is categorized for each isoform that overlaps with the genomic
    position of the mutation. Each transcript which passed the &#34;mutated&#34; or
    &#34;uncertain&#34; rule of the classification rules gets a new attribute
    `mutation_status` with the value &#34;mutated&#34; or &#34;uncertain&#34;.

    In addition to classifying mutations based on their impact on transcript
    isoforms, this function also assembles the mutation status on sample and
    gene level without further aggregation. The impact depends on the type of
    gene (&#34;gof&#34; or &#34;lof&#34;), so the impacts are assembled separately for each gene
    type:

    `sample_id` → `gene` → `gene_type` → `variant_id` → `mutationStatus`

    The impact of a particular mutational variant can be different for different
    overlapping transcript variants of a gene, and the transcript variants can
    also belong to different genes. The strongest impact on any overlapping
    transcript of a gene is defined as the impact of that mutational
    variant on the gene. The analyst must decide which isoforms are used to
    classify genes. For example, only canonical transcripts may be considered.
    Alternatively, all transcripts or a subset of transcripts may be used.
    Therefore, it is necessary to first apply transcript-level filters to all
    genomic positions  before determining the mutation status of genes.

    Args:
        positions: list of positions
        rule_set: rules for classifying &#34;gof&#34; and &#34;lof&#34; genes. See also
            `get_default_mutation_classification_rules()` for an example
            if the default rule set needs to be modified.
        gene_type_map: dictionary for mapping gene types to canonical gene
            types. See also `get_default_gene_type_map()` for an example
            if the default mapping table needs to be modified.

    Returns:
        A list of positions and a dictionary with assembled and aggregated
        mutations

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions, sample_muts = icap.apply_mutation_classification_rules(positions)
    &#34;&#34;&#34;
    sample_muts = {}
    mut_rank = {&#34;mutated&#34;: 0, &#34;uncertain&#34;: 1, &#34;not_mutated&#34;: 2, &#34;&#34;: 3}
    for gene_type, rules in tqdm(
        rule_set.items(), disable=hide_progress, desc=&#34;Level 1: Gene type&#34;
    ):
        for mut_status, filters in tqdm(
            rules.items(), disable=hide_progress, desc=&#34;Level 2: Mutation status&#34;
        ):
            for p in tqdm(positions, disable=hide_progress, desc=&#34;Level 3: Positions&#34;):
                if not filters[&#34;position_filter&#34;](p):
                    continue
                sample_ids = [x[&#34;sampleId&#34;] for x in p[&#34;samples&#34;]]
                for v in p.get(&#34;variants&#34;, []):
                    if not filters[&#34;variant_filter&#34;](v):
                        continue
                    for t in v.get(&#34;transcripts&#34;, []):
                        if not filters[&#34;transcript_filter&#34;](t):
                            continue
                        # Get the gene symbol
                        gene = t.get(&#34;hgnc&#34;, &#34;&#34;)
                        # Get the gene type of the current transcript or set it to ambiguous
                        # if the transcript has no gene type annotation
                        this_gene_type = t.get(&#34;geneType&#34;, &#34;ambiguous&#34;)
                        # Map the gene type to {&#39;gof&#39;}, {&#39;lof&#39;} or {&#39;gof&#39;, &#39;lof&#39;}
                        this_gene_type = gene_type_map.get(
                            this_gene_type, {&#34;gof&#34;, &#34;lof&#34;}
                        )
                        # Skip this transcript if the gene type for the current rule is not within
                        # the gene types of the current transcript
                        if gene_type not in this_gene_type:
                            continue
                        current_mut_status = t.get(&#34;mutationStatus&#34;, &#34;&#34;)
                        if mut_rank[mut_status] &lt;= mut_rank[current_mut_status]:
                            t[&#34;mutationStatus&#34;] = mut_status
                        for sample_id in sample_ids:
                            this_sample_muts = sample_muts.get(sample_id, {})
                            this_gene_muts = this_sample_muts.get(gene, {})
                            this_gene_type_mut_status = this_gene_muts.get(
                                gene_type, {}
                            )
                            this_variant_mut_status = this_gene_type_mut_status.get(
                                v[&#34;vid&#34;], &#34;&#34;
                            )
                            if (
                                mut_rank[mut_status]
                                &lt;= mut_rank[this_variant_mut_status]
                            ):
                                this_variant_mut_status = mut_status
                            this_gene_type_mut_status[
                                v[&#34;vid&#34;]
                            ] = this_variant_mut_status
                            this_gene_muts[gene_type] = this_gene_type_mut_status
                            this_sample_muts[gene] = this_gene_muts
                            sample_muts[sample_id] = this_sample_muts
    return positions, sample_muts</code></pre>
</details>
</dd>
<dt id="icaparser.cleanup_cosmic"><code class="name flex">
<span>def <span class="ident">cleanup_cosmic</span></span>(<span>positions)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove Cosmic entries with alleles not matching the variant alleles.</p>
<p>ICA attaches Cosmic entries to variants based on position only, which
leads to wrong assignments of Cosmic entries to variants. This function
removes all Cosmic entries from a variant for which reference and altered
alleles do not match those of the variant.</p>
<p>Filtering is done in place.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of positions to clean up</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>positions with cleaned up Cosmic entries</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup_cosmic(positions):
    &#34;&#34;&#34;Remove Cosmic entries with alleles not matching the variant alleles.

    ICA attaches Cosmic entries to variants based on position only, which
    leads to wrong assignments of Cosmic entries to variants. This function
    removes all Cosmic entries from a variant for which reference and altered
    alleles do not match those of the variant.

    Filtering is done in place.

    Args:
        positions: list of positions to clean up

    Returns:
        A list of positions with cleaned up Cosmic entries
    &#34;&#34;&#34;
    for p in positions:
        for v in p[&#34;variants&#34;]:
            if &#34;cosmic&#34; not in v:
                continue
            cosmic = []
            for c in v.get[&#34;cosmic&#34;]:
                # if c[&#39;refAllele&#39;] == variant[&#39;refAllele&#39;] and c[&#39;altAllele&#39;] == variant[&#39;altAllele&#39;]:
                if c.get(&#34;isAlleleSpecific&#34;, False):
                    cosmic.append(c)
            if len(cosmic) &gt; 0:
                v[&#34;cosmic&#34;] = cosmic
            else:
                del v[&#34;cosmic&#34;]
    return positions</code></pre>
</details>
</dd>
<dt id="icaparser.common_variant_filter"><code class="name flex">
<span>def <span class="ident">common_variant_filter</span></span>(<span>variant, max_af=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a variant filter based on GnomAD, GnomAd Exome, and 1000 Genomes.</p>
<p>Returns True if none of the maximum allele frequencies from GnomAD,
GnomAD Exome and 1000 Genomes is larger than <code>max_af</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
<dt><strong><code>max_af</code></strong></dt>
<dd>the mixum allele frequences threshold</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def common_variant_filter(variant, max_af=0.01):
    &#34;&#34;&#34;Get a variant filter based on GnomAD, GnomAd Exome, and 1000 Genomes.

    Returns True if none of the maximum allele frequencies from GnomAD,
    GnomAD Exome and 1000 Genomes is larger than `max_af`.

    Args:
        variant: the variant to investigate
        max_af: the mixum allele frequences threshold

    Returns:
        A bool
    &#34;&#34;&#34;
    passed = (
        get_gnomad_max_af(variant) &lt;= max_af
        and get_gnomad_exome_max_af(variant) &lt;= max_af
        and get_onekg_max_af(variant) &lt;= max_af
    )
    return passed</code></pre>
</details>
</dd>
<dt id="icaparser.explode_consequence"><code class="name flex">
<span>def <span class="ident">explode_consequence</span></span>(<span>mutation_table, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Explode the VEP consequence column of a mutation table.</p>
<p>Exploding the VEP consequence column with the standard Pandas
<code>explode()</code> function would return consquences as strings, not as
ordered categories. This function will instead return a consequence
columns which is an ordered category. The categories are ordered by
their impact.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mutation_table</code></strong></dt>
<dd>the mutation table to explode</dd>
<dt><strong><code>inplace</code></strong></dt>
<dd>if True, then modify the mutation_table in place instead
of returning a new object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.explode_consequence(mutation_table, inplace=True)
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; mutation_table_exploded = icap.explode_consequence(mutation_table)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def explode_consequence(mutation_table, inplace=False):
    &#34;&#34;&#34;Explode the VEP consequence column of a mutation table.

    Exploding the VEP consequence column with the standard Pandas
    `explode()` function would return consquences as strings, not as
    ordered categories. This function will instead return a consequence
    columns which is an ordered category. The categories are ordered by
    their impact.

    Args:
        mutation_table: the mutation table to explode
        inplace: if True, then modify the mutation_table in place instead
            of returning a new object

    Returns:
        A pandas.DataFrame

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.explode_consequence(mutation_table, inplace=True)

        &gt;&gt;&gt; mutation_table_exploded = icap.explode_consequence(mutation_table)
    &#34;&#34;&#34;
    vep_csq_cats = list(vep_csq.index)
    vep_csq_cats.reverse()
    if not inplace:
        mutation_table = deepcopy(mutation_table)
    mutation_table = mutation_table.explode(column=&#34;consequence&#34;)
    mutation_table[&#34;consequence&#34;] = pd.Categorical(
        mutation_table[&#34;consequence&#34;], categories=vep_csq_cats, ordered=True
    )
    return mutation_table</code></pre>
</details>
</dd>
<dt id="icaparser.filter_positions_by_transcripts"><code class="name flex">
<span>def <span class="ident">filter_positions_by_transcripts</span></span>(<span>positions, filter_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter positions based on a filter function for transcripts.</p>
<p>Apply a filter function to all transcripts of each position.
Transcripts not passing the filter are removed from a position.
Positions without any transcripts passing the filter are removed
from the returned list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of positions to filter</dd>
<dt><strong><code>filter_func</code></strong></dt>
<dd>function taking a transcript and returning a bool.
True means to keep the transcript.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; is_canonical_transcript = lambda x: x.get('isCanonical', False)
&gt;&gt;&gt; canonical_positions = icap.filter_positions_by_transcripts(
        non_common_positions,
        is_canonical_transcript
    )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_positions_by_transcripts(positions, filter_func):
    &#34;&#34;&#34;Filter positions based on a filter function for transcripts.

    Apply a filter function to all transcripts of each position.
    Transcripts not passing the filter are removed from a position.
    Positions without any transcripts passing the filter are removed
    from the returned list.

    Args:
        positions: list of positions to filter
        filter_func: function taking a transcript and returning a bool.
                     True means to keep the transcript.

    Returns:
        A list

    Example:
        &gt;&gt;&gt; is_canonical_transcript = lambda x: x.get(&#39;isCanonical&#39;, False)
        &gt;&gt;&gt; canonical_positions = icap.filter_positions_by_transcripts(
                non_common_positions,
                is_canonical_transcript
            )
    &#34;&#34;&#34;
    filtered_positions = []
    for position in positions:
        variants = position[&#34;variants&#34;]
        filtered_variants = filter_variants_by_transcripts(variants, filter_func)
        if filtered_variants:
            filtered_position = deepcopy(position)
            filtered_position[&#34;variants&#34;] = filtered_variants
            filtered_positions.append(filtered_position)
    return filtered_positions</code></pre>
</details>
</dd>
<dt id="icaparser.filter_positions_by_variants"><code class="name flex">
<span>def <span class="ident">filter_positions_by_variants</span></span>(<span>positions, filter_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter positions based on a filter function for variants.</p>
<p>Apply a filter function to all variants of each position.
Variants not passing the filter are removed from a position.
Positions without any variants passing the filter are removed
from the returned list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of positions to filter</dd>
<dt><strong><code>filter_func</code></strong></dt>
<dd>function taking a variant and returning a bool.
True means to keep the variant.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; ax_af = 0.01
&gt;&gt;&gt; is_not_common_variant = lambda x: icap.common_variant_filter(x, max_af)
&gt;&gt;&gt; non_common_positions = icap.filter_positions_by_variants(
        positions,
        is_not_common_variant
    )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_positions_by_variants(positions, filter_func):
    &#34;&#34;&#34;Filter positions based on a filter function for variants.

    Apply a filter function to all variants of each position.
    Variants not passing the filter are removed from a position.
    Positions without any variants passing the filter are removed
    from the returned list.

    Args:
        positions: list of positions to filter
        filter_func: function taking a variant and returning a bool.
                     True means to keep the variant.

    Returns:
        A list

    Example:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; ax_af = 0.01
        &gt;&gt;&gt; is_not_common_variant = lambda x: icap.common_variant_filter(x, max_af)
        &gt;&gt;&gt; non_common_positions = icap.filter_positions_by_variants(
                positions,
                is_not_common_variant
            )
    &#34;&#34;&#34;
    return _filter_items(positions, filter_func, &#34;variants&#34;)</code></pre>
</details>
</dd>
<dt id="icaparser.filter_variants_by_transcripts"><code class="name flex">
<span>def <span class="ident">filter_variants_by_transcripts</span></span>(<span>variants, filter_func)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter variants based on a filter function for transcripts.</p>
<p>Apply a filter function to all transcripts of each variant.
Transcripts not passing the filter are removed from a variant.
Variants without any transcripts passing the filter are removed
from the returned list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variants</code></strong></dt>
<dd>list of variants to filter</dd>
<dt><strong><code>filter_func</code></strong></dt>
<dd>function taking a transcript and returning a bool.
True means to keep the transcript.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_variants_by_transcripts(variants, filter_func):
    &#34;&#34;&#34;Filter variants based on a filter function for transcripts.

    Apply a filter function to all transcripts of each variant.
    Transcripts not passing the filter are removed from a variant.
    Variants without any transcripts passing the filter are removed
    from the returned list.

    Args:
        variants: list of variants to filter
        filter_func: function taking a transcript and returning a bool.
                     True means to keep the transcript.

    Returns:
        A list
    &#34;&#34;&#34;
    return _filter_items(variants, filter_func, &#34;transcripts&#34;)</code></pre>
</details>
</dd>
<dt id="icaparser.get_aggregated_mutation_table"><code class="name flex">
<span>def <span class="ident">get_aggregated_mutation_table</span></span>(<span>positions, mutation_classification_rules={&#x27;gof&#x27;: {&#x27;mutated&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}, &#x27;uncertain&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}}, &#x27;lof&#x27;: {&#x27;mutated&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}, &#x27;uncertain&#x27;: {&#x27;position_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;variant_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;transcript_filter&#x27;: &lt;function get_default_mutation_classification_rules.&lt;locals&gt;.&lt;lambda&gt;&gt;}}}, mutation_aggregation_rules={&#x27;gof&#x27;: &lt;function get_default_mutation_aggregation_rules.&lt;locals&gt;._aggregation_rules_gof&gt;, &#x27;lof&#x27;: &lt;function get_default_mutation_aggregation_rules.&lt;locals&gt;._aggregation_rules_lof&gt;}, gene_type_map={'oncogene': {'gof'}, 'tsg': {'lof'}, 'mixed': {'gof', 'lof'}, 'Act': {'gof'}, 'LoF': {'lof'}, 'ambiguous': {'gof', 'lof'}, '': {'gof', 'lof'}}, hide_progress=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a sample-gene-mutationStatus table.</p>
<p>This function applies mutation classification rules to all mutational
variants and aggregates the mutations according to the aggregation rules.
This results in a table with one row for each sample-gene pair. The table
contains several columns with impacts for "lof" and "gof" on allele level
and gene level and with one additional column with the maximum impact for
both allele and gene level.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>list of positions</dd>
<dt><strong><code>mutation_classification_rules</code></strong></dt>
<dd>rules for classifying single mutations.
See <code><a title="icaparser.get_default_mutation_classification_rules" href="#icaparser.get_default_mutation_classification_rules">get_default_mutation_classification_rules()</a></code> for details.</dd>
<dt><strong><code>mutation_aggregation_rules</code></strong></dt>
<dd>rules for aggregation mutations.
See <code>get_default_mutation_aggregation_reles()</code> for details.</dd>
<dt><strong><code>gene_type_map</code></strong></dt>
<dd>dictonary for mapping gene types to canonical gene types.
See <code><a title="icaparser.get_default_gene_type_map" href="#icaparser.get_default_gene_type_map">get_default_gene_type_map()</a></code> for details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A pandas.DataFrame with the mutation table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aggregated_mutation_table(
    positions,
    mutation_classification_rules=get_default_mutation_classification_rules(),
    mutation_aggregation_rules=get_default_mutation_aggregation_rules(),
    gene_type_map=get_default_gene_type_map(),
    hide_progress=False,
):
    &#34;&#34;&#34;Returns a sample-gene-mutationStatus table.

    This function applies mutation classification rules to all mutational
    variants and aggregates the mutations according to the aggregation rules.
    This results in a table with one row for each sample-gene pair. The table
    contains several columns with impacts for &#34;lof&#34; and &#34;gof&#34; on allele level
    and gene level and with one additional column with the maximum impact for
    both allele and gene level.

    Args:
        positions: list of positions
        mutation_classification_rules: rules for classifying single mutations.
            See `get_default_mutation_classification_rules()` for details.
        mutation_aggregation_rules: rules for aggregation mutations.
            See `get_default_mutation_aggregation_reles()` for details.
        gene_type_map: dictonary for mapping gene types to canonical gene types.
            See `get_default_gene_type_map()` for details.

    Returns:
        A pandas.DataFrame with the mutation table.
    &#34;&#34;&#34;
    gene_type_cache = {}
    for p in positions:
        for v in p.get(&#34;variants&#34;, []):
            for t in v.get(&#34;transcripts&#34;, []):
                gene_type_cache[t.get(&#34;hgnc&#34;, &#34;&#34;)] = t.get(&#34;geneType&#34;, &#34;&#34;)

    def get_max_mut_status(mut_status):
        if &#34;mutated&#34; in mut_status:
            return &#34;mutated&#34;
        elif &#34;uncertain&#34; in mut_status:
            return &#34;uncertain&#34;
        else:
            return &#34;not_mutated&#34;

    p, sample_muts = apply_mutation_classification_rules(
        positions,
        rule_set=mutation_classification_rules,
        gene_type_map=gene_type_map,
        hide_progress=hide_progress,
    )
    agg_mutation_table = pd.DataFrame()
    for sample_id, gene_muts in tqdm(
        sample_muts.items(), disable=hide_progress, desc=&#34;Samples&#34;
    ):
        for gene, gene_type_muts in gene_muts.items():
            gene_mut_counts = {}
            for gene_type, variant_muts in gene_type_muts.items():
                gene_type_mut_counts = gene_mut_counts.get(gene_type, {})
                for vid, mut_status in variant_muts.items():
                    mut_counts = gene_type_mut_counts.get(mut_status, 0)
                    mut_counts += 1
                    gene_type_mut_counts[mut_status] = mut_counts
                gene_mut_counts[gene_type] = gene_type_mut_counts
            gene_type = gene_type_cache.get(gene)
            canonical_gene_type = gene_type_map[gene_type]
            gof_allele_status = (
                mutation_aggregation_rules[&#34;gof&#34;](gene_mut_counts[&#34;gof&#34;])[0]
                if &#34;gof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            lof_allele_status = (
                mutation_aggregation_rules[&#34;lof&#34;](gene_mut_counts[&#34;lof&#34;])[0]
                if &#34;lof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            gof_gene_status = (
                mutation_aggregation_rules[&#34;gof&#34;](gene_mut_counts[&#34;gof&#34;])[1]
                if &#34;gof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            lof_gene_status = (
                mutation_aggregation_rules[&#34;lof&#34;](gene_mut_counts[&#34;lof&#34;])[1]
                if &#34;lof&#34; in gene_mut_counts
                else &#34;&#34;
            )
            row = pd.DataFrame.from_dict(
                {
                    &#34;sample_id&#34;: [sample_id],
                    &#34;gene&#34;: [gene],
                    &#34;geneType&#34;: [gene_type],
                    &#34;canonicalGeneType&#34;: [canonical_gene_type],
                    &#34;gof_mutated_count&#34;: [
                        gene_mut_counts.get(&#34;gof&#34;, {}).get(&#34;mutated&#34;, 0)
                        if ({&#34;gof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;gof_uncertain_count&#34;: [
                        gene_mut_counts.get(&#34;gof&#34;, {}).get(&#34;uncertain&#34;, 0)
                        if ({&#34;gof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;lof_mutated_count&#34;: [
                        gene_mut_counts.get(&#34;lof&#34;, {}).get(&#34;mutated&#34;, 0)
                        if ({&#34;lof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;lof_uncertain_count&#34;: [
                        gene_mut_counts.get(&#34;lof&#34;, {}).get(&#34;uncertain&#34;, 0)
                        if ({&#34;lof&#34;, &#34;&#34;} &amp; canonical_gene_type)
                        else np.NaN
                    ],
                    &#34;gof_allele_status&#34;: [gof_allele_status],
                    &#34;lof_allele_status&#34;: [lof_allele_status],
                    &#34;gof_gene_status&#34;: [gof_gene_status],
                    &#34;lof_gene_status&#34;: [lof_gene_status],
                    &#34;allele_status&#34;: [
                        get_max_mut_status((gof_allele_status, lof_allele_status))
                    ],
                    &#34;gene_status&#34;: [
                        get_max_mut_status((gof_gene_status, lof_gene_status))
                    ],
                    &#34;gene_or_allele_status&#34;: [
                        get_max_mut_status(
                            (
                                gof_allele_status,
                                lof_allele_status,
                                gof_gene_status,
                                lof_gene_status,
                            )
                        )
                    ],
                }
            )
            agg_mutation_table = pd.concat([agg_mutation_table, row], ignore_index=True)
    count_cols = [x for x in agg_mutation_table.columns if &#34;count&#34; in x]
    for col in count_cols:
        agg_mutation_table[col] = agg_mutation_table[col].astype(pd.Int64Dtype())
    return agg_mutation_table</code></pre>
</details>
</dd>
<dt id="icaparser.get_biotype_priority"><code class="name flex">
<span>def <span class="ident">get_biotype_priority</span></span>(<span>biotype)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the numeric priority of a biotype.</p>
<p>The numeric priority of a biotype that is returned by this function
is the same as defined by <a href="https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.">https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.</a>
Biotypes are 'protein_coding', 'LRG_gene', ,'miRNA', &hellip;</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>biotype</code></strong></dt>
<dd>a string with a single biotype</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer, smaller values mean higher priority</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_biotype_priority(biotype):
    &#34;&#34;&#34;Get the numeric priority of a biotype.

    The numeric priority of a biotype that is returned by this function
    is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.
    Biotypes are &#39;protein_coding&#39;, &#39;LRG_gene&#39;, ,&#39;miRNA&#39;, ...

    Args:
        biotype: a string with a single biotype

    Returns:
        An integer, smaller values mean higher priority

    &#34;&#34;&#34;
    lowest_prio = max(_BIOTYPE_PRIORITY.values())
    if biotype not in _BIOTYPE_PRIORITY.keys():
        warnings.warn(
            &#39;&#34;&#39;
            + biotype
            + &#39;&#34; is not a known biotype and will be set to the lowest priority of &#39;
            + str(lowest_prio)
            + &#34;.&#34;
        )
    return _BIOTYPE_PRIORITY.get(biotype, lowest_prio)</code></pre>
</details>
</dd>
<dt id="icaparser.get_clinvar"><code class="name flex">
<span>def <span class="ident">get_clinvar</span></span>(<span>variant)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a table of all ClinVar annotations for a variant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clinvar(variant):
    &#34;&#34;&#34;Get a table of all ClinVar annotations for a variant.

    Args:
        variant: the variant to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    if &#34;clinvar&#34; not in variant:
        return pd.DataFrame()
    return pd.DataFrame(variant[&#34;clinvar&#34;])</code></pre>
</details>
</dd>
<dt id="icaparser.get_clinvar_max_significance"><code class="name flex">
<span>def <span class="ident">get_clinvar_max_significance</span></span>(<span>variant, ordered_significances=['pathogenic', 'likely pathogenic', 'drug response', 'risk factor', 'protective', 'affects', 'association', 'uncertain significance', 'conflicting data from submitters', 'other', 'not provided', 'likely benign', 'benign'])</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum signifinance for all ClinVar annotations of a variant.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
<dt><strong><code>ordered_significances</code></strong></dt>
<dd>ranked order of ClinVar significances</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clinvar_max_significance(
    variant, ordered_significances=_CLINVAR_ORDERED_SIGNIFICANCES
):
    &#34;&#34;&#34;Get the maximum signifinance for all ClinVar annotations of a variant.

    Args:
        variant: the variant to investigate
        ordered_significances: ranked order of ClinVar significances

    Returns:
        A string
    &#34;&#34;&#34;
    if &#34;clinvar&#34; not in variant:
        return &#34;none&#34;
    significance_ranks = dict(
        zip(ordered_significances, list(range(len(ordered_significances))))
    )
    best_rank = max(significance_ranks.values()) + 1
    max_significance = &#34;none&#34;
    for clinvar in variant[&#34;clinvar&#34;]:
        for significance in clinvar[&#34;significance&#34;]:
            if significance not in significance_ranks:
                continue
            rank = significance_ranks[significance]
            if rank &lt; best_rank:
                best_rank = rank
                max_significance = significance
    return max_significance</code></pre>
</details>
</dd>
<dt id="icaparser.get_consequences"><code class="name flex">
<span>def <span class="ident">get_consequences</span></span>(<span>transcript)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of consequences for a transcript</p>
<p>A list of consequences for a transcript is returned. If any of the annotated
consequences is a combination if single consequences, separated by
ampersands ('&amp;') or commas, such a consequence is split into single consequences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transcript</code></strong></dt>
<dd>the transcript to get the consequences for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>strings</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_consequences(transcript):
    &#34;&#34;&#34;Get a list of consequences for a transcript

    A list of consequences for a transcript is returned. If any of the annotated
    consequences is a combination if single consequences, separated by
    ampersands (&#39;&amp;&#39;) or commas, such a consequence is split into single consequences.

    Args:
        transcript: the transcript to get the consequences for

    Returns:
        A list of strings
    &#34;&#34;&#34;
    consequences = transcript.get(&#34;consequence&#34;, [])
    consequences = [x for c in consequences for x in re.split(&#34;&amp;,&#34;, c)]
    return consequences</code></pre>
</details>
</dd>
<dt id="icaparser.get_cosmic_cancer_gene_census_tier"><code class="name flex">
<span>def <span class="ident">get_cosmic_cancer_gene_census_tier</span></span>(<span>variant)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the highest Cosmic Cancer Gene Census tier of a variant.</p>
<p>A variant can have no, one or multiple associated Cosmic identifiers.
This function returns the highest 'tier' for all of the Cosmic Cancer
Gene Census entries for a variant. There are two tiers, '1', and '2'.
Tier '1' is assigned to genes with documented activity relevant to cancer,
and tier '2' is assigned to genes with strong indications of a role in
cancer but with less extensive available evidence.</p>
<p>It is important to understand that this is the tier for a gene, not for a
particular variant, so it must not be mistaken with the Cosmic Cancer
Mutation Census tiers.</p>
<p>See <a href="https://cancer.sanger.ac.uk/census">https://cancer.sanger.ac.uk/census</a> for a detailed description of tiers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cosmic_cancer_gene_census_tier(variant):
    &#34;&#34;&#34;Get the highest Cosmic Cancer Gene Census tier of a variant.

    A variant can have no, one or multiple associated Cosmic identifiers.
    This function returns the highest &#39;tier&#39; for all of the Cosmic Cancer
    Gene Census entries for a variant. There are two tiers, &#39;1&#39;, and &#39;2&#39;.
    Tier &#39;1&#39; is assigned to genes with documented activity relevant to cancer,
    and tier &#39;2&#39; is assigned to genes with strong indications of a role in
    cancer but with less extensive available evidence.

    It is important to understand that this is the tier for a gene, not for a
    particular variant, so it must not be mistaken with the Cosmic Cancer
    Mutation Census tiers.
    
    See https://cancer.sanger.ac.uk/census for a detailed description of tiers.

    Args:
        variant:    the variant to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    best_tier = pd.NA
    for cosmic_entry in variant.get(&#34;cosmic&#34;, []):
        if not cosmic_entry.get(&#34;isAlleleSpecific&#34;, False):
            continue
        for tier_entry in cosmic_entry.get(&#34;tiersAndCounts&#34;, []):
            tier = int(tier_entry[&#34;tier&#34;])
            if best_tier is pd.NA:
                best_tier = tier
            else:
                best_tier = min(tier, best_tier)
    return best_tier</code></pre>
</details>
</dd>
<dt id="icaparser.get_cosmic_max_sample_count"><code class="name flex">
<span>def <span class="ident">get_cosmic_max_sample_count</span></span>(<span>variant, only_fully_annotated=False, only_allele_specific=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum sample count for all Cosmic annotations of a variant.</p>
<p>A variant can have no, one or multiple associated Cosmic identifiers.
This function returns the maximum sample count of all Cosmic identifers.
For each Cosmic identifiers, sample numbers are summed up across all indications.
Returns 0 if no Cosmic identifier exists for this variant.</p>
<p>The 'only_fully_annotated' argument can be used to exclude Cosmic entries
that have no 'cancerTypesAndCounts' annotation. If, for example, the
Cosmic VCF file used by ICA contained all Cosmic variants, but the
Cosmic TSV file used by ICA contained only Cancer Census variants, then
a variant that is in the VCF but not the TSV will have a simply annotation
without 'cancerTypesAndCounts', 'cancerSitesAndCounts', 'tiersAndCounts'.
So when setting 'only_fully_annotated' to True, only samples having a mutation
from the Cancer Census will be counted.</p>
<p>The 'only_allele_specific' argument is used to exclude Cosmic entries that
annotate the same chromosomal location but an allele that is different from
the allele of the annotated variant. ICA annotates a variant with all
Cosmic entries for that chromosomal location, irrespective of alleles.
When counting Cosmic samples, this leads to an overestimation of Cosmic
sample counts for a particular variant. Therefore, 'only_allele_specific'
is True by default to count only samples from Cosmic entries with matching
alleles. Occasionally, it may be desired, though, to count all samples with
mutations at a given position, irrespective of allele. For example, several
different alleles at a functional site of a gene can lead to function-disrupting
<br>
mutations, so we want to get the maximum sample count for any allele at
that position. One might also think of adding the samnple counts for all
Cosmic entries annotating a variant, but this does not work currently due
to redundancy of Cosmic entries. Older Cosmic versions often included the
same sample in different Cosmic entries. And newer Cosmic versions often
have multiple entries for an allele, one for each transcript variant, with
the same underlying samples.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>
<pre><code>     the variant to investigate
</code></pre>
</dd>
<dt><strong><code>only_fully_annotated</code></strong></dt>
<dd>consider only consmic entries which are fully
annotated, i.e. which have 'cancerTypesAndCounts'</dd>
<dt><strong><code>only_allele_specific</code></strong></dt>
<dd>consider only cosmic entries with alleles
matching the allele of the annotated variant</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cosmic_max_sample_count(
    variant, only_fully_annotated=False, only_allele_specific=True
):
    &#34;&#34;&#34;Get the maximum sample count for all Cosmic annotations of a variant.

    A variant can have no, one or multiple associated Cosmic identifiers.
    This function returns the maximum sample count of all Cosmic identifers.
    For each Cosmic identifiers, sample numbers are summed up across all indications.
    Returns 0 if no Cosmic identifier exists for this variant.

    The &#39;only_fully_annotated&#39; argument can be used to exclude Cosmic entries
    that have no &#39;cancerTypesAndCounts&#39; annotation. If, for example, the
    Cosmic VCF file used by ICA contained all Cosmic variants, but the
    Cosmic TSV file used by ICA contained only Cancer Census variants, then
    a variant that is in the VCF but not the TSV will have a simply annotation
    without &#39;cancerTypesAndCounts&#39;, &#39;cancerSitesAndCounts&#39;, &#39;tiersAndCounts&#39;.
    So when setting &#39;only_fully_annotated&#39; to True, only samples having a mutation
    from the Cancer Census will be counted.

    The &#39;only_allele_specific&#39; argument is used to exclude Cosmic entries that
    annotate the same chromosomal location but an allele that is different from
    the allele of the annotated variant. ICA annotates a variant with all
    Cosmic entries for that chromosomal location, irrespective of alleles.
    When counting Cosmic samples, this leads to an overestimation of Cosmic
    sample counts for a particular variant. Therefore, &#39;only_allele_specific&#39;
    is True by default to count only samples from Cosmic entries with matching
    alleles. Occasionally, it may be desired, though, to count all samples with
    mutations at a given position, irrespective of allele. For example, several
    different alleles at a functional site of a gene can lead to function-disrupting    
    mutations, so we want to get the maximum sample count for any allele at
    that position. One might also think of adding the samnple counts for all
    Cosmic entries annotating a variant, but this does not work currently due
    to redundancy of Cosmic entries. Older Cosmic versions often included the
    same sample in different Cosmic entries. And newer Cosmic versions often
    have multiple entries for an allele, one for each transcript variant, with
    the same underlying samples.

    Args:
        variant:              the variant to investigate
        only_fully_annotated: consider only consmic entries which are fully
                              annotated, i.e. which have &#39;cancerTypesAndCounts&#39;
        only_allele_specific: consider only cosmic entries with alleles
                              matching the allele of the annotated variant

    Returns:
        An integer
    &#34;&#34;&#34;
    max_count = 0
    for cosmic_entry in variant.get(&#34;cosmic&#34;, []):
        if only_fully_annotated and &#34;cancerTypesAndCounts&#34; not in cosmic_entry:
            continue
        if only_allele_specific and not cosmic_entry.get(&#34;isAlleleSpecific&#34;, False):
            continue
        max_count = max(max_count, cosmic_entry.get(&#34;sampleCount&#34;, 0))
    return max_count</code></pre>
</details>
</dd>
<dt id="icaparser.get_data_sources"><code class="name flex">
<span>def <span class="ident">get_data_sources</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a table with annotation data sources from the JSON header.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_sources(file):
    &#34;&#34;&#34;Extract a table with annotation data sources from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    header = get_header(file)
    df = pd.DataFrame(header[&#34;dataSources&#34;])
    return df</code></pre>
</details>
</dd>
<dt id="icaparser.get_default_gene_type_map"><code class="name flex">
<span>def <span class="ident">get_default_gene_type_map</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the default gene type map.</p>
<p>The canonical gene types are <code>gof</code>, <code>lof</code>, and the union of both.
Genes that need to be activated to drive a tumor are of type <code>gof</code>.
Genes that need to be deactivated to drive a tumor are of type <code>lof</code>.
Genes that need to be activated or deactivated depending on the context
are of the union of both types.
Genes for which it is unknown if they need to be activated or deactivated
are also annotated with both types.
Genes can be originally annotated with other type names than the canonical
ones. The gene type map is used to map these other gene type names to the
canonical gene types.</p>
<p>The default map is:</p>
<ul>
<li><code>oncogene</code> → <code>{"gof"}</code></li>
<li><code>tsg</code> → <code>{"lof"}</code></li>
<li><code>Act</code> → <code>{"gof"}</code></li>
<li><code>LoF</code> → <code>{"lof"}</code></li>
<li><code>mixed</code> → <code>{"gof", "lof"}</code></li>
<li><code>ambiguous</code> → <code>{"gof", "lof"}</code></li>
</ul>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dictionary with mappings from gene types to canonical gene types</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.get_default_gene_type_map()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_gene_type_map():
    &#34;&#34;&#34;Returns the default gene type map.

    The canonical gene types are `gof`, `lof`, and the union of both.
    Genes that need to be activated to drive a tumor are of type `gof`.
    Genes that need to be deactivated to drive a tumor are of type `lof`.
    Genes that need to be activated or deactivated depending on the context
    are of the union of both types.
    Genes for which it is unknown if they need to be activated or deactivated
    are also annotated with both types.
    Genes can be originally annotated with other type names than the canonical
    ones. The gene type map is used to map these other gene type names to the
    canonical gene types.

    The default map is:

    - `oncogene` → `{&#34;gof&#34;}`
    - `tsg` → `{&#34;lof&#34;}`
    - `Act` → `{&#34;gof&#34;}`
    - `LoF` → `{&#34;lof&#34;}`
    - `mixed` → `{&#34;gof&#34;, &#34;lof&#34;}`
    - `ambiguous` → `{&#34;gof&#34;, &#34;lof&#34;}`

    Returns:
        A dictionary with mappings from gene types to canonical gene types

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_gene_type_map()

    &#34;&#34;&#34;
    # Define some mappings of gene types to rule set keys
    gene_type_map = {
        &#34;oncogene&#34;: {&#34;gof&#34;},
        &#34;tsg&#34;: {&#34;lof&#34;},
        &#34;mixed&#34;: {&#34;gof&#34;, &#34;lof&#34;},
        &#34;Act&#34;: {&#34;gof&#34;},
        &#34;LoF&#34;: {&#34;lof&#34;},
        &#34;ambiguous&#34;: {&#34;gof&#34;, &#34;lof&#34;},
        &#34;&#34;: {&#34;gof&#34;, &#34;lof&#34;},
    }
    return gene_type_map</code></pre>
</details>
</dd>
<dt id="icaparser.get_default_mutation_aggregation_rules"><code class="name flex">
<span>def <span class="ident">get_default_mutation_aggregation_rules</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the default mutation aggregation rules.</p>
<p>Two types of the mutation status of a gene are introduced - allele level and
gene level:</p>
<ul>
<li>For "gof" genes (like oncogenes) it is sufficient if one of the alleles of
one of the relevant isoforms has an activating mutation.</li>
<li>For "lof" genes (like tumor suppressor genes) all alleles of all relevant
isoforms need to be functionally disrupted, either by mutations or by
other means.</li>
<li>For Mixed and Other genes, the impact of a mutation is defined as the
highest impact according to "gof" rules and "lof" rules.</li>
</ul>
<p>For "gof" genes, the allele and gene level classifications are identical
unless there is additional information about activating modifications other
than mutations. For "lof" genes, allele and gene level classifications
may be different. For example, a truncating mutation of a tumor suppressor
gene is functionally disruptive for the affected allele. However, there may
be other functionally active alleles of the same gene, i.e., the gene itself
may still be active. All alleles of such a gene must be dysfunctional,
either by additional mutations or by other processes, such as copy number
deletions or hypermethylation. Therefore, a single variant that is
disruptive at the allele level is not necessarily also disruptive at the
gene level. For "lof" genes, we usually do not have enough information
for a reliable estimation of functional effects. Instead, some heuristic
ules must be applied, and the analyst must decide whether to work with
allele-level or gene-level classifications. We designate a "lof" gene as
functionally disrupted (strong impact) if it has at least two mutations with
either strong impact or uncertain impact. If a "lof" gene has only one of
these mutations, it is designated as uncertain impact at the gene level,
even if one of these mutations has a strong impact at the allele level. By
categorizing effects at both allele and gene levels, we retain the
flexibility to decide in downstream analyses how to merge some of these
categories for subsequent statistical calculations.</p>
<p>Additional filters based on publications, white lists and black lists for
mutations can be applied. These are not part of the first version and will
be added later. White and black lists can be based, for example, on ClinVar
and on the publication by Hess et al. (2019).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dictionary</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.get_default_mutation_aggregation_rules()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_mutation_aggregation_rules():
    &#34;&#34;&#34;Returns the default mutation aggregation rules.

    Two types of the mutation status of a gene are introduced - allele level and
    gene level:

    - For &#34;gof&#34; genes (like oncogenes) it is sufficient if one of the alleles of
        one of the relevant isoforms has an activating mutation.
    - For &#34;lof&#34; genes (like tumor suppressor genes) all alleles of all relevant
        isoforms need to be functionally disrupted, either by mutations or by
        other means.
    - For Mixed and Other genes, the impact of a mutation is defined as the
        highest impact according to &#34;gof&#34; rules and &#34;lof&#34; rules.

    For &#34;gof&#34; genes, the allele and gene level classifications are identical
    unless there is additional information about activating modifications other
    than mutations. For &#34;lof&#34; genes, allele and gene level classifications
    may be different. For example, a truncating mutation of a tumor suppressor
    gene is functionally disruptive for the affected allele. However, there may
    be other functionally active alleles of the same gene, i.e., the gene itself
    may still be active. All alleles of such a gene must be dysfunctional,
    either by additional mutations or by other processes, such as copy number
    deletions or hypermethylation. Therefore, a single variant that is
    disruptive at the allele level is not necessarily also disruptive at the
    gene level. For &#34;lof&#34; genes, we usually do not have enough information
    for a reliable estimation of functional effects. Instead, some heuristic
    ules must be applied, and the analyst must decide whether to work with
    allele-level or gene-level classifications. We designate a &#34;lof&#34; gene as
    functionally disrupted (strong impact) if it has at least two mutations with
    either strong impact or uncertain impact. If a &#34;lof&#34; gene has only one of
    these mutations, it is designated as uncertain impact at the gene level,
    even if one of these mutations has a strong impact at the allele level. By
    categorizing effects at both allele and gene levels, we retain the
    flexibility to decide in downstream analyses how to merge some of these
    categories for subsequent statistical calculations.

    Additional filters based on publications, white lists and black lists for
    mutations can be applied. These are not part of the first version and will
    be added later. White and black lists can be based, for example, on ClinVar
    and on the publication by Hess et al. (2019).

    Returns:
        A dictionary

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_mutation_aggregation_rules()
    &#34;&#34;&#34;

    def _aggregation_rules_gof(mut_counts):
        if mut_counts.get(&#34;mutated&#34;, 0) &gt;= 1:
            allele_level = gene_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 1:
            allele_level = gene_level = &#34;uncertain&#34;
        else:
            allele_level = gene_level = &#34;not_mutated&#34;
        return allele_level, gene_level

    def _aggregation_rules_lof(mut_counts):
        # allele level
        if mut_counts.get(&#34;mutated&#34;, 0) &gt;= 1:
            allele_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 1:
            allele_level = &#34;uncertain&#34;
        else:
            allele_level = &#34;not_mutated&#34;
        # gene level
        if mut_counts.get(&#34;mutated&#34;, 0) + mut_counts.get(&#34;uncertain&#34;, 0) &gt;= 2:
            gene_level = &#34;mutated&#34;
        elif mut_counts.get(&#34;mutated&#34;, 0) + mut_counts.get(&#34;uncertain&#34;, 0) == 1:
            gene_level = &#34;uncertain&#34;
        else:
            gene_level = &#34;not_mutated&#34;
        return allele_level, gene_level

    mutation_aggregation_rules = {
        &#34;gof&#34;: _aggregation_rules_gof,
        &#34;lof&#34;: _aggregation_rules_lof,
    }

    return mutation_aggregation_rules</code></pre>
</details>
</dd>
<dt id="icaparser.get_default_mutation_classification_rules"><code class="name flex">
<span>def <span class="ident">get_default_mutation_classification_rules</span></span>(<span>cosmic_threshold=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the default rules for classifying mutations.</p>
<p>Defines the default rules for classifying mutations. The returned dictonary
has keys "gof" and "lof", and the respective values are the rule sets for
these gene types. A rule set is again a dictionary with the keys "mutated"
and "uncertain". The values for "mutated" or "uncertain" are dictionaries
with three filter functions, a "position_filter", a "variant_filter", and
a "transcript filter". For example, a transcript will be called "mutated"
if all three filters for "mutated" return True, and it will be called
"uncertain", if all three filter functions for "uncertain" return True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cosmic_threshold</code></strong></dt>
<dd>for "gof" genes, this is the "hotspot threshold" for
Cosmic, i.e., the minimum number of samples in Cosmic having that
mutation to consider a mutation a hot spot and, therefore, call the
mutation "mutated". If the number of Cosmic samples is smaller, the
mutation is called "uncertain".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dictionary with mutation classification rules</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.get_default_mutation_classification_rules()
&gt;&gt;&gt; icap.get_default_mutation_classification_rules(cosmic_threshold=20)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_mutation_classification_rules(cosmic_threshold=10):
    &#34;&#34;&#34;Returns the default rules for classifying mutations.

    Defines the default rules for classifying mutations. The returned dictonary
    has keys &#34;gof&#34; and &#34;lof&#34;, and the respective values are the rule sets for
    these gene types. A rule set is again a dictionary with the keys &#34;mutated&#34;
    and &#34;uncertain&#34;. The values for &#34;mutated&#34; or &#34;uncertain&#34; are dictionaries
    with three filter functions, a &#34;position_filter&#34;, a &#34;variant_filter&#34;, and
    a &#34;transcript filter&#34;. For example, a transcript will be called &#34;mutated&#34;
    if all three filters for &#34;mutated&#34; return True, and it will be called
    &#34;uncertain&#34;, if all three filter functions for &#34;uncertain&#34; return True.

    Args:
        cosmic_threshold: for &#34;gof&#34; genes, this is the &#34;hotspot threshold&#34; for
            Cosmic, i.e., the minimum number of samples in Cosmic having that
            mutation to consider a mutation a hot spot and, therefore, call the
            mutation &#34;mutated&#34;. If the number of Cosmic samples is smaller, the
            mutation is called &#34;uncertain&#34;.

    Returns:
        A dictionary with mutation classification rules

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_default_mutation_classification_rules()
        &gt;&gt;&gt; icap.get_default_mutation_classification_rules(cosmic_threshold=20)

    &#34;&#34;&#34;
    classification_rules = {
        &#34;gof&#34;: {
            # potentially activating mutations (inframe indels, missense mutations)
            # that are hotspots. Currently, hotspots are defined by Cosmic only.
            &#34;mutated&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: (
                    get_cosmic_max_sample_count(v) &gt;= cosmic_threshold
                ),
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
            # potentially activating mutations (inframe indels, missense mutations)
            # that are not hotspots
            &#34;uncertain&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: (
                    get_cosmic_max_sample_count(v) &lt; cosmic_threshold
                ),
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
        },
        &#34;lof&#34;: {
            # disruptive mutations (transcript_ablation, splice_acceptor_variant,
            # splice_donor_variant, stop_gained, stop_lost, start_lost,
            # frameshift_variant)
            &#34;mutated&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: True,
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &lt;= 4
                ),
            },
            # potentially disruptive mutations (inframe indels, missense mutations)
            &#34;uncertain&#34;: {
                &#34;position_filter&#34;: lambda p: True,
                &#34;variant_filter&#34;: lambda v: True,
                &#34;transcript_filter&#34;: lambda t: (
                    get_strongest_vep_consequence_priority(t) &gt; 4
                    and get_strongest_vep_consequence_priority(t) &lt;= 6
                ),
            },
        },
    }
    return classification_rules</code></pre>
</details>
</dd>
<dt id="icaparser.get_dna_json_files"><code class="name flex">
<span>def <span class="ident">get_dna_json_files</span></span>(<span>base_dir, pattern='*MergedVariants_Annotated_filtered.json.gz')</span>
</code></dt>
<dd>
<div class="desc"><p>Find DNA annotation JSON files in or below <code>base_dir</code>.</p>
<p>Searches for ICA DNA annotation JSON files in and below <code>base_dir</code>.
All file names matching <code>pattern</code> are returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_dir</code></strong></dt>
<dd>base directory of directory subtree where to search
for DNA annotation JSON files</dd>
<dt><strong><code>pattern</code></strong></dt>
<dd>files names matching this pattern are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code> of <code>file names</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dna_json_files(base_dir, pattern=&#34;*MergedVariants_Annotated_filtered.json.gz&#34;):
    &#34;&#34;&#34;Find DNA annotation JSON files in or below `base_dir`.

    Searches for ICA DNA annotation JSON files in and below `base_dir`.
    All file names matching `pattern` are returned.

    Args:
        base_dir: base directory of directory subtree where to search
                  for DNA annotation JSON files
        pattern:  files names matching this pattern are returned

    Returns:
        A list of file names
    &#34;&#34;&#34;
    files = [x.as_posix() for x in Path(base_dir).rglob(pattern)]
    files = sorted(files)
    return files</code></pre>
</details>
</dd>
<dt id="icaparser.get_gene_type"><code class="name flex">
<span>def <span class="ident">get_gene_type</span></span>(<span>gene_symbol)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the gene type (oncogene, tsg, mixed) for a gene.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gene_symbol</code></strong></dt>
<dd>the gene symbol of the gene</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>a string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gene_type(gene_symbol):
    &#34;&#34;&#34;Get the gene type (oncogene, tsg, mixed) for a gene.

    Args:
        gene_symbol: the gene symbol of the gene

    Returns:
        a string
    &#34;&#34;&#34;
    if gene_symbol in gene_type.index:
        return gene_type.loc[gene_symbol, &#34;gene_type&#34;]
    else:
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="icaparser.get_genes"><code class="name flex">
<span>def <span class="ident">get_genes</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract gene annotation from a ICA JSON file.</p>
<p>The <code>genes</code> section of ICA JSON files is optional. If this section
is not included in the file, an empty list is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_genes(file):
    &#34;&#34;&#34;Extract gene annotation from a ICA JSON file.

    The `genes` section of ICA JSON files is optional. If this section
    is not included in the file, an empty list is returned.

    Args:
        file: name of the ICA JSON file

    Returns:
        A list
    &#34;&#34;&#34;
    return _get_branch(file, &#34;genes&#34;)</code></pre>
</details>
</dd>
<dt id="icaparser.get_gnomad_exome_max_af"><code class="name flex">
<span>def <span class="ident">get_gnomad_exome_max_af</span></span>(<span>variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum allele frequency for gnomAD Exome.</p>
<p>Get the maximum allele frequences across all major cohorts annotated
by gnomAD, Exome
excluding bottleneck populations (Ashkenazy Jews and
Finish) and <em>other</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
<dt><strong><code>cohorts</code></strong></dt>
<dd>subpopulations to include</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gnomad_exome_max_af(
        variant,
        cohorts = [&#34;afr&#34;, &#34;amr&#34;, &#34;eas&#34;, &#34;nfe&#34;, &#34;sas&#34;]
        ):
    &#34;&#34;&#34;Get the maximum allele frequency for gnomAD Exome.

    Get the maximum allele frequences across all major cohorts annotated
    by gnomAD, Exome  excluding bottleneck populations (Ashkenazy Jews and
    Finish) and _other_.

    Args:
        variant: the variant to investigate
        cohorts: subpopulations to include

    Returns:
        A float
    &#34;&#34;&#34;
    return get_max_af(variant, &#34;gnomadExome&#34;, cohorts)</code></pre>
</details>
</dd>
<dt id="icaparser.get_gnomad_max_af"><code class="name flex">
<span>def <span class="ident">get_gnomad_max_af</span></span>(<span>variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum allele frequency for gnomAD.</p>
<p>Get the maximum allele frequences across all major cohorts annotated
by gnomAD, excluding bottleneck populations (Ashkenazy Jews and Finish)
and <em>other</em>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
<dt><strong><code>cohorts</code></strong></dt>
<dd>subpopulations to include</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gnomad_max_af(
        variant,
        cohorts = [&#34;afr&#34;, &#34;amr&#34;, &#34;eas&#34;, &#34;nfe&#34;, &#34;sas&#34;]
        ):
    &#34;&#34;&#34;Get the maximum allele frequency for gnomAD.

    Get the maximum allele frequences across all major cohorts annotated
    by gnomAD, excluding bottleneck populations (Ashkenazy Jews and Finish)
    and _other_.

    Args:
        variant: the variant to investigate
        cohorts: subpopulations to include

    Returns:
        A float
    &#34;&#34;&#34;
    
    return get_max_af(variant, &#34;gnomad&#34;, cohorts)</code></pre>
</details>
</dd>
<dt id="icaparser.get_header"><code class="name flex">
<span>def <span class="ident">get_header</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the header element from a ICA JSON file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dictionary with the header from the JSON file</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header(file):
    &#34;&#34;&#34;Extract the header element from a ICA JSON file.

    Args:
        file: name of the ICA JSON file

    Returns:
        A dictionary with the header from the JSON file
    &#34;&#34;&#34;
    with gzip.open(file, &#34;rt&#34;) as f:
        line = next(f)
    trim_line = line.strip()
    header = trim_line[10:-14]
    header = json.loads(header)
    return header</code></pre>
</details>
</dd>
<dt id="icaparser.get_header_scalars"><code class="name flex">
<span>def <span class="ident">get_header_scalars</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a table with all scalar attributes from the JSON header.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header_scalars(file):
    &#34;&#34;&#34;Extract a table with all scalar attributes from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    header = get_header(file)
    sample = get_sample(file)
    df = pd.DataFrame([x for x in header.items() if not isinstance(x[1], list)])
    df = df.rename(columns={0: &#34;Attribute&#34;, 1: sample})
    return df</code></pre>
</details>
</dd>
<dt id="icaparser.get_max_af"><code class="name flex">
<span>def <span class="ident">get_max_af</span></span>(<span>variant, source, cohorts=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum allele frequency for a particular annotation source.</p>
<p>Get the maximum allele frequency across all cohorts annotated by the
annotation source.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
<dt><strong><code>source</code></strong></dt>
<dd>the annotation source to use</dd>
<dt><strong><code>cohorts</code></strong></dt>
<dd>subpopulations to include; include all if cohorts == None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.get_max_af(variant, 'gnomad')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_af(variant, source, cohorts = None):
    &#34;&#34;&#34;Get the maximum allele frequency for a particular annotation source.

    Get the maximum allele frequency across all cohorts annotated by the
    annotation source.

    Args:
        variant: the variant to investigate
        source: the annotation source to use
        cohorts: subpopulations to include; include all if cohorts == None

    Returns:
        A float

    Example:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_max_af(variant, &#39;gnomad&#39;)
    &#34;&#34;&#34;
    if not source in variant:
        return 0
    max_af = 0
    for k, v in variant[source].items():
        if k.endswith(&#34;Af&#34;):
            if not cohorts or k.replace(&#34;Af&#34;, &#34;&#34;) in cohorts:
                max_af = max(max_af, v)
    return max_af</code></pre>
</details>
</dd>
<dt id="icaparser.get_multi_sample_positions"><code class="name flex">
<span>def <span class="ident">get_multi_sample_positions</span></span>(<span>files, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract all positions for a set of ICA JSON files.</p>
<p>The sample id is stored as an additional new attribute of the
<code>samples</code> element of a position. The <code>samples</code> element is a list,
although ICA usually only creates single sample JSON files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>files</code></strong></dt>
<dd>names of the ICA JSON files</dd>
<dt><strong><code>args</code></strong></dt>
<dd>extra arguments forwarded to get_positions()</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>extra named arguments forwarded to get_positions()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; positions = icap.get_multi_sample_positions(json_files)
&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_multi_sample_positions(files, *args, **kwargs):
    &#34;&#34;&#34;Extract all positions for a set of ICA JSON files.

    The sample id is stored as an additional new attribute of the
    `samples` element of a position. The `samples` element is a list,
    although ICA usually only creates single sample JSON files.

    Args:
        files: names of the ICA JSON files
        args: extra arguments forwarded to get_positions()
        kwargs: extra named arguments forwarded to get_positions()

    Returns:
        A list

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; positions = icap.get_multi_sample_positions(json_files)
        &gt;&gt;&gt; print(positions[0][&#39;samples&#39;][0][&#39;sampleId&#39;])
    &#34;&#34;&#34;
    positions = []
    for f in tqdm(files):
        positions += get_positions(f, *args, **kwargs)
    return positions</code></pre>
</details>
</dd>
<dt id="icaparser.get_mutation_table_for_files"><code class="name flex">
<span>def <span class="ident">get_mutation_table_for_files</span></span>(<span>json_files, max_af=0.01, min_vep_consequence_priority=6, min_cosmic_sample_count=0, only_canonical=False, extra_variant_filters=[], extra_transcript_filters=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Get an annotated table of all filtered transcripts from a list of ICA JSON files.</p>
<p>Load all positions from a list of ICA JSON files and filter them.
Positions having any remaining variants and transcripts passing the filter
are returned as an annotated table.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>files</code></strong></dt>
<dd>list of ICA JSON files</dd>
<dt><strong><code>max_af</code></strong></dt>
<dd>maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.
Only variants with maximum allele frequencies below this threshold
will be returned.</dd>
<dt><strong><code>min_vep_consequence_priority</code></strong></dt>
<dd>only transcripts with a minimum VEP
consequence priority not larger than this threshold will be retained</dd>
<dt><strong><code>min_cosmic_sample_count</code></strong></dt>
<dd>only variants with a maximum cosmic sample count
not lower than this threshold will be retained</dd>
<dt><strong><code>only_canonical</code></strong></dt>
<dd>if true, only canonical transcripts will be retained</dd>
<dt><strong><code>extra_variant_filters</code></strong></dt>
<dd>any additional filters to apply to variants.
Filters shall return True to keep a variant.</dd>
<dt><strong><code>extra_transcript_filters</code></strong></dt>
<dd>any additional filters to apply to transcripts.
Filters shall return True to keep a transcript.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; extra_transcript_filters = [
        lambda x: x.get('source', '') == 'Ensembl',
        lambda x: x.get('hgnc', '') == 'KRAS'
    ]
&gt;&gt;&gt; mut_table = icap.get_mutation_table_for_files(
        json_files,
        extra_transcript_filters=extra_transcript_filters
    )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mutation_table_for_files(
    json_files,
    max_af=0.01,
    min_vep_consequence_priority=6,
    min_cosmic_sample_count=0,
    only_canonical=False,
    extra_variant_filters=[],
    extra_transcript_filters=[],
):
    &#34;&#34;&#34;Get an annotated table of all filtered transcripts from a list of ICA JSON files.

    Load all positions from a list of ICA JSON files and filter them.
    Positions having any remaining variants and transcripts passing the filter
    are returned as an annotated table.

    Args:
        files:  list of ICA JSON files
        max_af: maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.
                Only variants with maximum allele frequencies below this threshold
                will be returned.
        min_vep_consequence_priority: only transcripts with a minimum VEP
                consequence priority not larger than this threshold will be retained
        min_cosmic_sample_count: only variants with a maximum cosmic sample count
                not lower than this threshold will be retained
        only_canonical: if true, only canonical transcripts will be retained
        extra_variant_filters: any additional filters to apply to variants.
                Filters shall return True to keep a variant.
        extra_transcript_filters: any additional filters to apply to transcripts.
                Filters shall return True to keep a transcript.

    Returns:
        A pandas.DataFrame

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; extra_transcript_filters = [
                lambda x: x.get(&#39;source&#39;, &#39;&#39;) == &#39;Ensembl&#39;,
                lambda x: x.get(&#39;hgnc&#39;, &#39;&#39;) == &#39;KRAS&#39;
            ]
        &gt;&gt;&gt; mut_table = icap.get_mutation_table_for_files(
                json_files,
                extra_transcript_filters=extra_transcript_filters
            )
    &#34;&#34;&#34;
    df = pd.concat(
        [
            _get_mutation_table_for_single_file(
                x,
                max_af=max_af,
                min_vep_consequence_priority=min_vep_consequence_priority,
                min_cosmic_sample_count=min_cosmic_sample_count,
                only_canonical=only_canonical,
                extra_variant_filters=extra_variant_filters,
                extra_transcript_filters=extra_transcript_filters,
            )
            for x in tqdm(json_files)
        ],
        ignore_index=True,
    )
    # If none of the positions passes the filters, return the empty dataframe.
    # For an empty dataframe, the rest of this function would fail because the
    # empty dataframe does not contain these columns.
    if df.empty:
        return df
    # Make chromosome a categorical veriable set sorting order
    df[&#34;chromosome&#34;] = df[&#34;chromosome&#34;].astype(&#34;category&#34;)
    df[&#34;chromosome&#34;] = df[&#34;chromosome&#34;].cat.reorder_categories(
        natsorted(df[&#34;chromosome&#34;].cat.categories), ordered=True
    )
    # Make isCanonical an ordered categorical variable
    df[&#34;isCanonical&#34;] = pd.Categorical(df[&#34;isCanonical&#34;], ordered=True)
    return df</code></pre>
</details>
</dd>
<dt id="icaparser.get_mutation_table_for_position"><code class="name flex">
<span>def <span class="ident">get_mutation_table_for_position</span></span>(<span>position)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an annotated table of all transcripts.</p>
<p>Returns an annotated table of all transcripts that are affected
by a mutation at a position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong></dt>
<dd>the position to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mutation_table_for_position(position):
    &#34;&#34;&#34;Get an annotated table of all transcripts.

    Returns an annotated table of all transcripts that are affected
    by a mutation at a position.

    Args:
        position: the position to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    vep_csq_categories = list(vep_csq.index)
    vep_csq_categories.reverse()
    df = pd.DataFrame()
    for variant_idx, variant in enumerate(position[&#34;variants&#34;]):
        # Get the variant frequency for this variant
        variant_frequencies = position[&#34;samples&#34;][0].get(&#34;variantFrequencies&#34;, [])
        if variant_idx &lt; len(variant_frequencies):
            variant_frequency = variant_frequencies[variant_idx]
        else:
            variant_frequency = np.nan
        # Create the table rows
        for transcript in variant[&#34;transcripts&#34;]:
            row = pd.DataFrame.from_dict(
                {
                    &#34;sample&#34;: [position[&#34;samples&#34;][0][&#34;sampleId&#34;]],
                    &#34;chromosome&#34;: [position[&#34;chromosome&#34;]],
                    &#34;position&#34;: [position[&#34;position&#34;]],
                    &#34;genotype&#34;: [position.get(&#34;samples&#34;)[0].get(&#34;genotype&#34;)],
                    &#34;variantFrequency&#34;: [variant_frequency],
                    &#34;hgnc&#34;: [transcript.get(&#34;hgnc&#34;, &#34;&#34;)],
                    &#34;source&#34;: [transcript.get(&#34;source&#34;, &#34;&#34;)],
                    &#34;geneId&#34;: [transcript.get(&#34;geneId&#34;, &#34;&#34;)],
                    &#34;transcriptId&#34;: [transcript.get(&#34;transcript&#34;, &#34;&#34;)],
                    &#34;proteinId&#34;: [transcript.get(&#34;proteinId&#34;, &#34;&#34;)],
                    &#34;hgvsg&#34;: [variant.get(&#34;hgvsg&#34;, &#34;&#34;)],
                    &#34;hgvsc&#34;: [transcript.get(&#34;hgvsc&#34;, &#34;&#34;)],
                    &#34;hgvsp&#34;: [transcript.get(&#34;hgvsp&#34;, &#34;&#34;)],
                    &#34;isCanonical&#34;: [transcript.get(&#34;isCanonical&#34;, False)],
                    &#34;vid&#34;: [variant[&#34;vid&#34;]],
                    &#34;begin&#34;: [variant[&#34;begin&#34;]],
                    &#34;end&#34;: [variant[&#34;end&#34;]],
                    &#34;refAllele&#34;: [variant[&#34;refAllele&#34;]],
                    &#34;altAllele&#34;: [variant[&#34;altAllele&#34;]],
                    &#34;variantType&#34;: [variant[&#34;variantType&#34;]],
                    &#34;bioType&#34;: [transcript.get(&#34;bioType&#34;, &#34;&#34;)],
                    &#34;geneType&#34;: [transcript.get(&#34;geneType&#34;, &#34;&#34;)],
                    &#34;mutationStatus&#34;: [transcript.get(&#34;mutationStatus&#34;, &#34;&#34;)],
                    &#34;codons&#34;: [transcript.get(&#34;codons&#34;, &#34;&#34;)],
                    &#34;aminoAcids&#34;: [transcript.get(&#34;aminoAcids&#34;, &#34;&#34;)],
                    &#34;cdnaPos&#34;: [transcript.get(&#34;cdnaPos&#34;, &#34;&#34;)],
                    &#34;cdsPos&#34;: [transcript.get(&#34;cdsPos&#34;, &#34;&#34;)],
                    &#34;exons&#34;: [transcript.get(&#34;exons&#34;, &#34;&#34;)],
                    &#34;proteinPos&#34;: [transcript.get(&#34;proteinPos&#34;, &#34;&#34;)],
                    &#34;consequence&#34;: [transcript.get(&#34;consequence&#34;, [])],
                    &#34;cosmicSampleCount&#34;: [get_cosmic_max_sample_count(variant)],
                    &#34;cosmicGeneTier&#34;: [get_cosmic_cancer_gene_census_tier(variant)],
                    &#34;maxGnomadAf&#34;: [get_gnomad_max_af(variant)],
                    &#34;maxGnomadExomeAf&#34;: [get_gnomad_exome_max_af(variant)],
                    &#34;maxOneKG&#34;: [get_onekg_max_af(variant)],
                }
            )
            df = pd.concat([df, row], ignore_index=True)
    return df</code></pre>
</details>
</dd>
<dt id="icaparser.get_mutation_table_for_positions"><code class="name flex">
<span>def <span class="ident">get_mutation_table_for_positions</span></span>(<span>positions, hide_progress=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an annotated table of all transcripts for all positions.</p>
<p>Returns an annotated table of all transcripts that are affected
by a mutation at any of the position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>the positions to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mutation_table_for_positions(positions, hide_progress=False):
    &#34;&#34;&#34;Get an annotated table of all transcripts for all positions.

    Returns an annotated table of all transcripts that are affected
    by a mutation at any of the position.

    Args:
        positions: the positions to investigate

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;

    if len(positions) == 0:
        return pd.DataFrame()
    mutation_tables = []
    for p in tqdm(positions, disable=hide_progress, desc=&#34;Positions&#34;):
        mutation_tables.append(get_mutation_table_for_position(p))
    if len(mutation_tables) == 0:
        return pd.DataFrame()
    mutation_table = pd.concat(mutation_tables, ignore_index=True)
    return mutation_table</code></pre>
</details>
</dd>
<dt id="icaparser.get_onekg_max_af"><code class="name flex">
<span>def <span class="ident">get_onekg_max_af</span></span>(<span>variant)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum allele frequency for the 1000 Genomes Project.</p>
<p>Get the maximum allele frequences across all cohorts annotated
by the 1000 Genomes Project.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variant</code></strong></dt>
<dd>the variant to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_onekg_max_af(variant):
    &#34;&#34;&#34;Get the maximum allele frequency for the 1000 Genomes Project.

    Get the maximum allele frequences across all cohorts annotated
    by the 1000 Genomes Project.

    Args:
        variant: the variant to investigate

    Returns:
        A float
    &#34;&#34;&#34;
    return get_max_af(variant, &#34;oneKg&#34;)</code></pre>
</details>
</dd>
<dt id="icaparser.get_pipeline_metadata"><code class="name flex">
<span>def <span class="ident">get_pipeline_metadata</span></span>(<span>files)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a table with metadata annotation pipeline run from the JSON header.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A pandas.DataFrame</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pipeline_metadata(files):
    &#34;&#34;&#34;Extract a table with metadata annotation pipeline run from the JSON header.

    Args:
        file: name of the ICA JSON file

    Returns:
        A pandas.DataFrame
    &#34;&#34;&#34;
    df = get_header_scalars(files[0])
    for fname in files[1:]:
        df = pd.merge(df, get_header_scalars(fname), on=&#34;Attribute&#34;, how=&#34;outer&#34;)
    df = df.set_index(&#34;Attribute&#34;).transpose()
    df.index.rename(&#34;Sample&#34;, inplace=True)
    return df</code></pre>
</details>
</dd>
<dt id="icaparser.get_position_by_coordinates"><code class="name flex">
<span>def <span class="ident">get_position_by_coordinates</span></span>(<span>positions, chromosome, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract a particular position from a position list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>a list of positions</dd>
<dt><strong><code>chromosome</code></strong></dt>
<dd>name of the chromosome</dd>
<dt><strong><code>position</code></strong></dt>
<dd>numeric posion on the chromosome</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A dict</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; import icaparser as icap
&gt;&gt;&gt; icap.get_position_by_coordinates(positions, 'chr1', 204399064)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_position_by_coordinates(positions, chromosome, position):
    &#34;&#34;&#34;Extract a particular position from a position list.

    Args:
        positions: a list of positions
        chromosome: name of the chromosome
        position: numeric posion on the chromosome

    Returns:
        A dict

    Examples:
        &gt;&gt;&gt; import icaparser as icap
        &gt;&gt;&gt; icap.get_position_by_coordinates(positions, &#39;chr1&#39;, 204399064)
    &#34;&#34;&#34;
    filter_func = lambda x: x[&#34;chromosome&#34;] == chromosome and x[&#34;position&#34;] == int(
        position
    )
    return list(filter(filter_func, positions))[0]</code></pre>
</details>
</dd>
<dt id="icaparser.get_positions"><code class="name flex">
<span>def <span class="ident">get_positions</span></span>(<span>file, variant_filters=[], transcript_filters=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Extract all positions from a ICA JSON file.</p>
<p>The sample id is stored as an additional new attribute of the
<code>samples</code> element of a position. The <code>samples</code> element is a list,
although ICA usually only creates single sample JSON files.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
<dt><strong><code>variant_filters</code></strong></dt>
<dd>any filters to apply to variants.
Filters shall return True to keep a variant.</dd>
<dt><strong><code>transcript_filters</code></strong></dt>
<dd>any filters to apply to transcripts.
Filters shall return True to keep a transcript.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A list</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python">&gt;&gt;&gt; transcript_filters = [
        lambda x: x.get('source', '') == 'Ensembl',
        lambda x: x.get('hgnc', '') == 'KRAS'
    ]
&gt;&gt;&gt; positions = icap.get_sample_positions(
        json_file,
        transcript_filters = transcript_filters
    )
&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_positions(file, variant_filters=[], transcript_filters=[]):
    &#34;&#34;&#34;Extract all positions from a ICA JSON file.

    The sample id is stored as an additional new attribute of the
    `samples` element of a position. The `samples` element is a list,
    although ICA usually only creates single sample JSON files.

    Args:
        file: name of the ICA JSON file
        variant_filters: any filters to apply to variants.
                Filters shall return True to keep a variant.
        transcript_filters: any filters to apply to transcripts.
                Filters shall return True to keep a transcript.

    Returns:
        A list

    Examples:
        &gt;&gt;&gt; transcript_filters = [
                lambda x: x.get(&#39;source&#39;, &#39;&#39;) == &#39;Ensembl&#39;,
                lambda x: x.get(&#39;hgnc&#39;, &#39;&#39;) == &#39;KRAS&#39;
            ]
        &gt;&gt;&gt; positions = icap.get_sample_positions(
                json_file,
                transcript_filters = transcript_filters
            )
        &gt;&gt;&gt; print(positions[0][&#39;samples&#39;][0][&#39;sampleId&#39;])
    &#34;&#34;&#34;
    positions = _get_branch(file, &#34;positions&#34;)
    positions = add_gene_types(positions)
    for vf in variant_filters:
        positions = filter_positions_by_variants(positions, vf)
    for tf in transcript_filters:
        positions = filter_positions_by_transcripts(positions, tf)
    sample_id = get_sample(file)
    for p in positions:
        p[&#34;samples&#34;][0][&#34;sampleId&#34;] = sample_id
    return positions</code></pre>
</details>
</dd>
<dt id="icaparser.get_sample"><code class="name flex">
<span>def <span class="ident">get_sample</span></span>(<span>file, suffix='(-D[^.]*)?\\.bam')</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the sample name from a ICA JSON file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong></dt>
<dd>name of the ICA JSON file</dd>
<dt><strong><code>suffix</code></strong></dt>
<dd>regular expression to remove from the sample name in the JSON
file. Defaults to '(-D[^.]*)?.bam'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A string with the name</code> of <code>the sample annotated in the JSON file</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample(file, suffix=&#34;(-D[^.]*)?\\.bam&#34;):
    &#34;&#34;&#34;Extract the sample name from a ICA JSON file.

    Args:
        file: name of the ICA JSON file
        suffix: regular expression to remove from the sample name in the JSON
            file. Defaults to &#39;(-D[^.]*)?\\.bam&#39;.

    Returns:
        A string with the name of the sample annotated in the JSON file
    &#34;&#34;&#34;
    header = get_header(file)
    sample = header[&#34;samples&#34;][0]
    sample = re.sub(suffix, &#34;&#34;, sample)
    return sample</code></pre>
</details>
</dd>
<dt id="icaparser.get_strongest_vep_consequence_name"><code class="name flex">
<span>def <span class="ident">get_strongest_vep_consequence_name</span></span>(<span>transcript)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of the strongest VEP consequence for a transcript.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transcript</code></strong></dt>
<dd>the transcript to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strongest_vep_consequence_name(transcript):
    &#34;&#34;&#34;Get the name of the strongest VEP consequence for a transcript.

    Args:
        transcript: the transcript to investigate

    Returns:
        A string
    &#34;&#34;&#34;
    rank = get_strongest_vep_consequence_rank(transcript)
    return get_vep_consequence_for_rank(rank)</code></pre>
</details>
</dd>
<dt id="icaparser.get_strongest_vep_consequence_priority"><code class="name flex">
<span>def <span class="ident">get_strongest_vep_consequence_priority</span></span>(<span>transcript)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the strongest priority of VEP consequence for a transcript.</p>
<p>Get the strongest numeric priority of all VEP consequences
for a transcript. Smaller numeric priorities mean stronger impact.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transcript</code></strong></dt>
<dd>the transcript to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strongest_vep_consequence_priority(transcript):
    &#34;&#34;&#34;Get the strongest priority of VEP consequence for a transcript.

    Get the strongest numeric priority of all VEP consequences
    for a transcript. Smaller numeric priorities mean stronger impact.

    Args:
        transcript: the transcript to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    if &#34;consequence&#34; not in transcript:
        return vep_csq[&#34;priority&#34;].max() + 1
    consequences = get_consequences(transcript)
    min_prio = vep_csq.loc[consequences, &#34;priority&#34;].min()
    return min_prio</code></pre>
</details>
</dd>
<dt id="icaparser.get_strongest_vep_consequence_rank"><code class="name flex">
<span>def <span class="ident">get_strongest_vep_consequence_rank</span></span>(<span>transcript)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the strongest rank of VEP consequences for a transcript.</p>
<p>Get the strongest numeric rank of all VEP consequences
for a transcript. Smaller ranks mean stronger impact.</p>
<p>The priority of consequences is taken into account first. So if
two consequences have different priorities, the consequence with
the higher priority (lower priority number) will be used, and the
rank for this consequence will be returned. If there are multiple
consequences with the same priority, the lowest (strongest) rank
will be returned.</p>
<p>For clarification: ranks are unique, i.e. all VEP consequences
ordered as listed on the VEP documentation page get the row number
of this table assigned as rank.</p>
<p>However, several consequences can have the same priority (e.g., stop
gained and frameshift have the same priority). Priorities are copied
from vcf2maf.pl.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transcript</code></strong></dt>
<dd>the transcript to investigate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_strongest_vep_consequence_rank(transcript):
    &#34;&#34;&#34;Get the strongest rank of VEP consequences for a transcript.

    Get the strongest numeric rank of all VEP consequences
    for a transcript. Smaller ranks mean stronger impact.

    The priority of consequences is taken into account first. So if
    two consequences have different priorities, the consequence with
    the higher priority (lower priority number) will be used, and the
    rank for this consequence will be returned. If there are multiple
    consequences with the same priority, the lowest (strongest) rank
    will be returned.

    For clarification: ranks are unique, i.e. all VEP consequences
    ordered as listed on the VEP documentation page get the row number
    of this table assigned as rank.

    However, several consequences can have the same priority (e.g., stop
    gained and frameshift have the same priority). Priorities are copied
    from vcf2maf.pl.

    Args:
        transcript: the transcript to investigate

    Returns:
        An integer
    &#34;&#34;&#34;
    if &#34;consequence&#34; not in transcript:
        return vep_csq[&#34;rank&#34;].max() + 1
    consequences = get_consequences(transcript)
    df = vep_csq.loc[consequences]
    strongest_prio = df.priority.min()
    min_rank = df[df.priority == strongest_prio][&#34;rank&#34;].min()
    return min_rank</code></pre>
</details>
</dd>
<dt id="icaparser.get_vep_consequence_for_rank"><code class="name flex">
<span>def <span class="ident">get_vep_consequence_for_rank</span></span>(<span>rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the VEP consequence term of a numeric rank.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rank</code></strong></dt>
<dd>the numeric rank of the consequence term</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A string</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vep_consequence_for_rank(rank):
    &#34;&#34;&#34;Get the VEP consequence term of a numeric rank.

    Args:
        rank: the numeric rank of the consequence term

    Returns:
        A string
    &#34;&#34;&#34;
    if rank &gt; vep_csq.shape[0]:
        return &#34;unknown&#34;
    else:
        return list(vep_csq[vep_csq[&#34;rank&#34;] == rank].index)[0]</code></pre>
</details>
</dd>
<dt id="icaparser.get_vep_priority_for_consequence"><code class="name flex">
<span>def <span class="ident">get_vep_priority_for_consequence</span></span>(<span>consequence)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the numeric priority of a VEP consequence term.</p>
<p>The numeric priority of a consequence that is returned by this function
is the same as defined by <a href="https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.">https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.</a></p>
<h2 id="args">Args</h2>
<pre><code>consequence: the consequence term of the mutation
</code></pre>
<p>Returns:
An integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vep_priority_for_consequence(consequence):
    &#34;&#34;&#34;Get the numeric priority of a VEP consequence term.

      The numeric priority of a consequence that is returned by this function
      is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.

    Args:
          consequence: the consequence term of the mutation

      Returns:
          An integer
    &#34;&#34;&#34;
    if consequence not in vep_csq.index:
        return vep_csq[&#34;priority&#34;].max() + 1
    return vep_csq.loc[consequence, &#34;priority&#34;]</code></pre>
</details>
</dd>
<dt id="icaparser.get_vep_rank_for_consequence"><code class="name flex">
<span>def <span class="ident">get_vep_rank_for_consequence</span></span>(<span>consequence)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the numeric rank of a VEP consequence term.</p>
<p>The numeric rank of a consequence that is the position of the consequence
in this list of consequences at <a href="https://www.ensembl.org/info/genome/variation/prediction/predicted_data.html">https://www.ensembl.org/info/genome/variation/prediction/predicted_data.html</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>consequence</code></strong></dt>
<dd>the consequence term of the mutation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>An integer</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vep_rank_for_consequence(consequence):
    &#34;&#34;&#34;Get the numeric rank of a VEP consequence term.

    The numeric rank of a consequence that is the position of the consequence
    in this list of consequences at https://www.ensembl.org/info/genome/variation/prediction/predicted_data.html

    Args:
        consequence: the consequence term of the mutation

    Returns:
        An integer
    &#34;&#34;&#34;
    if consequence not in vep_csq.index:
        return vep_csq[&#34;rank&#34;].max() + 1
    return vep_csq.loc[consequence, &#34;rank&#34;]</code></pre>
</details>
</dd>
<dt id="icaparser.split_multi_sample_json_file"><code class="name flex">
<span>def <span class="ident">split_multi_sample_json_file</span></span>(<span>json_file, output_dir)</span>
</code></dt>
<dd>
<div class="desc"><p>Splits a multi-sample JSON file into sample specifc JSON files.</p>
<p>This function reads a multi-sample JSON file that was generated by
annotating a multi-sample VCF file with ICA and splits it into
sample-specific JSON files.</p>
<p>Annotating very many single-sample VCF files with ICA is very time
consuming, because ICA reads all annotation sources for each VCF file
and this is dominating the runtime of ICA. It is therefore helpful to
first merge many single-sample VCF files into one or a small number of
multi-sample VCF files (for example, with <code>bcftools merge</code>), to annotate
the multi-sample VCF file with ICA, and then to split the multi-sample
JSON output of ICA into single-sample JSON files. These single-sample
JSON files are required for the rest of this package.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>json_file</code></strong></dt>
<dd>the multi-sample json input file</dd>
<dt><strong><code>output_dir</code></strong></dt>
<dd>the directory where to write the single sample JSON files.
The directory will be created if it does not exist.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_multi_sample_json_file(json_file, output_dir):
    &#34;&#34;&#34;Splits a multi-sample JSON file into sample specifc JSON files.

    This function reads a multi-sample JSON file that was generated by
    annotating a multi-sample VCF file with ICA and splits it into
    sample-specific JSON files.

    Annotating very many single-sample VCF files with ICA is very time
    consuming, because ICA reads all annotation sources for each VCF file
    and this is dominating the runtime of ICA. It is therefore helpful to
    first merge many single-sample VCF files into one or a small number of
    multi-sample VCF files (for example, with `bcftools merge`), to annotate
    the multi-sample VCF file with ICA, and then to split the multi-sample
    JSON output of ICA into single-sample JSON files. These single-sample
    JSON files are required for the rest of this package.

    Args:
        json_file: the multi-sample json input file
        output_dir: the directory where to write the single sample JSON files.
            The directory will be created if it does not exist.

    Returns:
        Nothing
    &#34;&#34;&#34;
    os.makedirs(output_dir, exist_ok=True)
    is_header_line = True
    is_position_line = False
    is_first_position_line = {}
    is_gene_line = False
    is_first_gene_line = {}
    header_end = &#39;,&#34;positions&#34;:[&#39;
    gene_section_line = &#39;],&#34;genes&#34;:[&#39;
    end_line = &#34;]}&#34;
    ofiles = {}
    genes = {}
    with gzip.open(json_file, &#34;rt&#34;) as fin:
        for line in fin:
            trim_line = line.strip()
            if is_header_line:
                is_header_line = False
                is_position_line = True
                header_json = trim_line[: -len(header_end)] + &#34;}&#34;
                header = json.loads(header_json)[&#34;header&#34;]
                samples = header[&#34;samples&#34;]
                for sample in samples:
                    is_first_position_line[sample] = True
                    s_header = header.copy()
                    s_header[&#34;samples&#34;] = [sample]
                    s_header_json = json.dumps(
                        {&#34;header&#34;: s_header}, separators=(&#34;,&#34;, &#34;:&#34;)
                    )
                    s_header_line = s_header_json[:-1] + header_end
                    s_fname = os.path.join(output_dir, sample + &#34;.json.gz&#34;)
                    ofiles[sample] = gzip.open(s_fname, &#34;wt&#34;)
                    print(s_header_line, file=ofiles[sample])
                continue
            if trim_line == gene_section_line:
                is_position_line = False
                is_gene_line = True
                for sample in samples:
                    is_first_gene_line[sample] = True
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=ofiles[sample])
                continue
            elif trim_line == end_line:
                for sample in samples:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=ofiles[sample])
                break
            else:
                if is_position_line:
                    ## remove the training &#39;,&#39; if there is
                    position_json = trim_line.rstrip(&#34;,&#34;)
                    position = json.loads(position_json)
                    p_samples = position[&#34;samples&#34;]
                    for sample_idx, sample in enumerate(samples):
                        p_sample = p_samples[sample_idx].copy()
                        # Continue if this sample is not mutated here
                        if p_sample[&#34;genotype&#34;] in (&#34;0/0&#34;, &#34;./.&#34;):
                            continue
                        # Get the variant indeces for this sample
                        variant_idxs = p_sample[&#34;genotype&#34;]
                        variant_idxs = variant_idxs.split(&#34;/&#34;)
                        variant_idxs = set(variant_idxs) - set(&#34;0&#34;)
                        variant_idxs = map(lambda x: int(x) - 1, list(variant_idxs))
                        variant_idxs = sorted(variant_idxs)
                        # Get the new genotype name for this sample
                        s_gt = p_sample[&#34;genotype&#34;]
                        s_gt = s_gt.split(&#34;/&#34;)
                        s_gt = [
                            int(x) - min(variant_idxs) if x != &#34;0&#34; else 0 for x in s_gt
                        ]
                        s_gt = &#34;/&#34;.join(map(str, s_gt))
                        p_sample[&#34;genotype&#34;] = s_gt
                        # Adjust the list of variantFrequencies
                        if len(p_sample.get(&#34;variantFrequencies&#34;, [])) &gt; 0:
                            p_sample[&#34;variantFrequencies&#34;] = [
                                p_sample[&#34;variantFrequencies&#34;][i] for i in variant_idxs
                            ]
                        else:
                            p_sample[&#34;variantFrequencies&#34;] = []
                        # Adjust the list of alleleDepths
                        if len(p_sample.get(&#34;alleleDepths&#34;, [])) &gt; 0:
                            p_sample[&#34;alleleDepths&#34;] = [p_sample[&#34;alleleDepths&#34;][0]] + [
                                p_sample[&#34;alleleDepths&#34;][i + 1] for i in variant_idxs
                            ]
                        else:
                            p_sample[&#34;alleleDepths&#34;] = []
                        # Keep only alleles relevant for this sample
                        s_position = position.copy()
                        s_position[&#34;samples&#34;] = [p_sample]
                        s_position[&#34;altAlleles&#34;] = [
                            s_position[&#34;altAlleles&#34;][i] for i in variant_idxs
                        ]
                        s_position[&#34;variants&#34;] = [
                            s_position[&#34;variants&#34;][i] for i in variant_idxs
                        ]
                        if is_first_position_line[sample]:
                            finish_prev_line = &#34;&#34;
                            genes[sample] = set()
                        else:
                            finish_prev_line = &#34;,\n&#34;
                        print(
                            finish_prev_line,
                            json.dumps(s_position, separators=(&#34;,&#34;, &#34;:&#34;)),
                            sep=&#34;&#34;,
                            end=&#34;&#34;,
                            file=ofiles[sample],
                        )
                        for variant in position.get(&#34;variants&#34;, []):
                            for transcript in variant.get(&#34;transcripts&#34;, []):
                                if &#34;hgnc&#34; in transcript:
                                    genes[sample].add(transcript[&#34;hgnc&#34;])
                        is_first_position_line[sample] = False
                if is_gene_line:
                    ## remove the trailing &#34;,&#34; if there is
                    gene_json = trim_line.rstrip(&#34;,&#34;)
                    gene = json.loads(gene_json)[&#34;name&#34;]
                    for sample_idx, sample in enumerate(samples):
                        if sample in genes and gene in genes[sample]:
                            if is_first_gene_line[sample]:
                                finish_prv_line = &#34;&#34;
                            else:
                                finish_prv_line = &#34;,\n&#34;
                            print(
                                finish_prv_line,
                                gene_json,
                                sep=&#34;&#34;,
                                end=&#34;&#34;,
                                file=ofiles[sample],
                            )
                            is_first_gene_line[sample] = False
    # Close the output files
    for ofile in ofiles.values():
        ofile.close()</code></pre>
</details>
</dd>
<dt id="icaparser.strip_json_file"><code class="name flex">
<span>def <span class="ident">strip_json_file</span></span>(<span>ifname, ofname)</span>
</code></dt>
<dd>
<div class="desc"><p>Reduce the JSON file size by keeping only 'PASS' variants.</p>
<p>JSON files from Illumina's ICA pipeline can be very large because they
contain any deviation from the reference genome, irrespective of the
quality of the mutation call. Gzip compressed JSON files with sizes in the
gigabyte range cannot be processed by JSON packages that read the entire
file into memory. It is necessary to first reduce the size of JSON files by
removing all variants that do not meet Illumina's quality criteria.</p>
<p>This function reads a single JSON file and creates a single JSON outpout
file by removing all variants that do not pass Illumina's quality criteria.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ifname</code></strong></dt>
<dd>name of the
input file</dd>
<dt><strong><code>ofname</code></strong></dt>
<dd>name of the output file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_json_file(ifname, ofname):
    &#34;&#34;&#34;Reduce the JSON file size by keeping only &#39;PASS&#39; variants.

    JSON files from Illumina&#39;s ICA pipeline can be very large because they
    contain any deviation from the reference genome, irrespective of the
    quality of the mutation call. Gzip compressed JSON files with sizes in the
    gigabyte range cannot be processed by JSON packages that read the entire
    file into memory. It is necessary to first reduce the size of JSON files by
    removing all variants that do not meet Illumina&#39;s quality criteria.

    This function reads a single JSON file and creates a single JSON outpout
    file by removing all variants that do not pass Illumina&#39;s quality criteria.

    Args:
        ifname: name of the  input file
        ofname: name of the output file

    Returns:
        Nothing
    &#34;&#34;&#34;
    if ifname == ofname:
        raise ValueError(&#34;ifname and ofname must be different&#34;)
    odname = os.path.dirname(ofname)
    os.makedirs(odname, exist_ok=True)
    header = &#34;&#34;
    is_header_line = True
    is_position_line = False
    is_first_position_line = False
    is_gene_line = False
    is_first_gene_line = False
    gene_section_line = &#39;],&#34;genes&#34;:[&#39;
    end_line = &#34;]}&#34;
    with gzip.open(ifname, &#34;rt&#34;) as fin:
        with gzip.open(ofname, &#34;wt&#34;) as fout:
            for line in fin:
                trim_line = line.strip()
                if is_header_line:
                    print(trim_line, file=fout)
                    is_header_line = False
                    is_position_line = True
                    is_first_position_line = True
                    continue
                if trim_line == gene_section_line:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=fout)
                    is_gene_line = True
                    is_first_gene_line = True
                    is_position_line = False
                    continue
                elif trim_line == end_line:
                    print(&#34;&#34;, trim_line, sep=&#34;\n&#34;, file=fout)
                    break
                else:
                    if is_position_line:
                        ## remove the trailing &#39;,&#39; if there is
                        position_json = trim_line.rstrip(&#34;,&#34;)
                        position = json.loads(position_json)
                        if &#34;PASS&#34; in position[&#34;filters&#34;]:
                            if is_first_position_line:
                                finish_prev_line = &#34;&#34;
                            else:
                                finish_prev_line = &#34;,\n&#34;
                            print(
                                finish_prev_line,
                                position_json,
                                sep=&#34;&#34;,
                                end=&#34;&#34;,
                                file=fout,
                            )
                            is_first_position_line = False
                    if is_gene_line:
                        ## remove the trailing &#39;,&#39; if there is
                        gene_json = trim_line.rstrip(&#34;,&#34;)
                        if is_first_gene_line:
                            finish_prev_line = &#34;&#34;
                        else:
                            finish_prev_line = &#34;,\n&#34;
                        print(finish_prev_line, gene_json, sep=&#34;&#34;, end=&#34;&#34;, file=fout)
                        is_first_gene_line = False</code></pre>
</details>
</dd>
<dt id="icaparser.strip_json_files"><code class="name flex">
<span>def <span class="ident">strip_json_files</span></span>(<span>source_dir, target_dir, pattern='*.json.gz')</span>
</code></dt>
<dd>
<div class="desc"><p>Strip all JSON files of a project by keeping only 'PASS' variants.</p>
<p>JSON files from Illumina's ICA pipeline can be very large because they
contain any deviation from the reference genome, irrespective of the
quality of the mutation call. Gzip compressed JSON files with sizes in the
gigabyte range cannot be processed by JSON packages that read the entire
file into memory. It is necessary to first reduce the size of JSON files by
removing all variants that do not meet Illumina's quality criteria.</p>
<p>This function searches <code>source_dir</code> recursively for all files matching the
<code>file_pattern</code>. Each of those files is processed and a stripped version
keeping only variants that PASS Illumina's quality criteria is created. The
output file has the same name as the input file. The directory structure
below <code>source_dir</code> is replicated in <code>target_dir</code>. Output files get the
suffix '_filtered.json.gz'.‚</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source_dir</code></strong></dt>
<dd>directory where to search for input JSON files</dd>
<dt><strong><code>target_dir</code></strong></dt>
<dd>directory where to save the stripped outpout JSON files</dd>
<dt><strong><code>file_pattern</code></strong></dt>
<dd>files matching this pattern will be processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Nothing</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; strip_json_files('../Data/Original', '../Data/Derived')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_json_files(source_dir, target_dir, pattern=&#34;*.json.gz&#34;):
    &#34;&#34;&#34;Strip all JSON files of a project by keeping only &#39;PASS&#39; variants.

    JSON files from Illumina&#39;s ICA pipeline can be very large because they
    contain any deviation from the reference genome, irrespective of the
    quality of the mutation call. Gzip compressed JSON files with sizes in the
    gigabyte range cannot be processed by JSON packages that read the entire
    file into memory. It is necessary to first reduce the size of JSON files by
    removing all variants that do not meet Illumina&#39;s quality criteria.

    This function searches `source_dir` recursively for all files matching the
    `file_pattern`. Each of those files is processed and a stripped version
    keeping only variants that PASS Illumina&#39;s quality criteria is created. The
    output file has the same name as the input file. The directory structure
    below `source_dir` is replicated in `target_dir`. Output files get the
    suffix &#39;_filtered.json.gz&#39;.‚

    Args:
        source_dir: directory where to search for input JSON files
        target_dir: directory where to save the stripped outpout JSON files
        file_pattern: files matching this pattern will be processed

    Returns:
        Nothing

    Example:
        &gt;&gt;&gt; strip_json_files(&#39;../Data/Original&#39;, &#39;../Data/Derived&#39;)
    &#34;&#34;&#34;
    source_dir = Path(source_dir).absolute()
    target_dir = Path(target_dir).absolute()
    if source_dir == target_dir:
        raise ValueError(&#34;source and target directory must be different&#34;)
    for path in tqdm(list(source_dir.rglob(pattern))):
        ifname = path.as_posix()
        ofname = ifname.replace(source_dir.as_posix(), target_dir.as_posix(), 1)
        ofname = ofname.removesuffix(&#34;.json.gz&#34;) + &#34;_filtered.json.gz&#34;
        tqdm.write(&#34;Stripping &#34; + ifname)
        strip_json_file(ifname, ofname)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="icaparser.add_gene_types" href="#icaparser.add_gene_types">add_gene_types</a></code></li>
<li><code><a title="icaparser.apply_mutation_classification_rules" href="#icaparser.apply_mutation_classification_rules">apply_mutation_classification_rules</a></code></li>
<li><code><a title="icaparser.cleanup_cosmic" href="#icaparser.cleanup_cosmic">cleanup_cosmic</a></code></li>
<li><code><a title="icaparser.common_variant_filter" href="#icaparser.common_variant_filter">common_variant_filter</a></code></li>
<li><code><a title="icaparser.explode_consequence" href="#icaparser.explode_consequence">explode_consequence</a></code></li>
<li><code><a title="icaparser.filter_positions_by_transcripts" href="#icaparser.filter_positions_by_transcripts">filter_positions_by_transcripts</a></code></li>
<li><code><a title="icaparser.filter_positions_by_variants" href="#icaparser.filter_positions_by_variants">filter_positions_by_variants</a></code></li>
<li><code><a title="icaparser.filter_variants_by_transcripts" href="#icaparser.filter_variants_by_transcripts">filter_variants_by_transcripts</a></code></li>
<li><code><a title="icaparser.get_aggregated_mutation_table" href="#icaparser.get_aggregated_mutation_table">get_aggregated_mutation_table</a></code></li>
<li><code><a title="icaparser.get_biotype_priority" href="#icaparser.get_biotype_priority">get_biotype_priority</a></code></li>
<li><code><a title="icaparser.get_clinvar" href="#icaparser.get_clinvar">get_clinvar</a></code></li>
<li><code><a title="icaparser.get_clinvar_max_significance" href="#icaparser.get_clinvar_max_significance">get_clinvar_max_significance</a></code></li>
<li><code><a title="icaparser.get_consequences" href="#icaparser.get_consequences">get_consequences</a></code></li>
<li><code><a title="icaparser.get_cosmic_cancer_gene_census_tier" href="#icaparser.get_cosmic_cancer_gene_census_tier">get_cosmic_cancer_gene_census_tier</a></code></li>
<li><code><a title="icaparser.get_cosmic_max_sample_count" href="#icaparser.get_cosmic_max_sample_count">get_cosmic_max_sample_count</a></code></li>
<li><code><a title="icaparser.get_data_sources" href="#icaparser.get_data_sources">get_data_sources</a></code></li>
<li><code><a title="icaparser.get_default_gene_type_map" href="#icaparser.get_default_gene_type_map">get_default_gene_type_map</a></code></li>
<li><code><a title="icaparser.get_default_mutation_aggregation_rules" href="#icaparser.get_default_mutation_aggregation_rules">get_default_mutation_aggregation_rules</a></code></li>
<li><code><a title="icaparser.get_default_mutation_classification_rules" href="#icaparser.get_default_mutation_classification_rules">get_default_mutation_classification_rules</a></code></li>
<li><code><a title="icaparser.get_dna_json_files" href="#icaparser.get_dna_json_files">get_dna_json_files</a></code></li>
<li><code><a title="icaparser.get_gene_type" href="#icaparser.get_gene_type">get_gene_type</a></code></li>
<li><code><a title="icaparser.get_genes" href="#icaparser.get_genes">get_genes</a></code></li>
<li><code><a title="icaparser.get_gnomad_exome_max_af" href="#icaparser.get_gnomad_exome_max_af">get_gnomad_exome_max_af</a></code></li>
<li><code><a title="icaparser.get_gnomad_max_af" href="#icaparser.get_gnomad_max_af">get_gnomad_max_af</a></code></li>
<li><code><a title="icaparser.get_header" href="#icaparser.get_header">get_header</a></code></li>
<li><code><a title="icaparser.get_header_scalars" href="#icaparser.get_header_scalars">get_header_scalars</a></code></li>
<li><code><a title="icaparser.get_max_af" href="#icaparser.get_max_af">get_max_af</a></code></li>
<li><code><a title="icaparser.get_multi_sample_positions" href="#icaparser.get_multi_sample_positions">get_multi_sample_positions</a></code></li>
<li><code><a title="icaparser.get_mutation_table_for_files" href="#icaparser.get_mutation_table_for_files">get_mutation_table_for_files</a></code></li>
<li><code><a title="icaparser.get_mutation_table_for_position" href="#icaparser.get_mutation_table_for_position">get_mutation_table_for_position</a></code></li>
<li><code><a title="icaparser.get_mutation_table_for_positions" href="#icaparser.get_mutation_table_for_positions">get_mutation_table_for_positions</a></code></li>
<li><code><a title="icaparser.get_onekg_max_af" href="#icaparser.get_onekg_max_af">get_onekg_max_af</a></code></li>
<li><code><a title="icaparser.get_pipeline_metadata" href="#icaparser.get_pipeline_metadata">get_pipeline_metadata</a></code></li>
<li><code><a title="icaparser.get_position_by_coordinates" href="#icaparser.get_position_by_coordinates">get_position_by_coordinates</a></code></li>
<li><code><a title="icaparser.get_positions" href="#icaparser.get_positions">get_positions</a></code></li>
<li><code><a title="icaparser.get_sample" href="#icaparser.get_sample">get_sample</a></code></li>
<li><code><a title="icaparser.get_strongest_vep_consequence_name" href="#icaparser.get_strongest_vep_consequence_name">get_strongest_vep_consequence_name</a></code></li>
<li><code><a title="icaparser.get_strongest_vep_consequence_priority" href="#icaparser.get_strongest_vep_consequence_priority">get_strongest_vep_consequence_priority</a></code></li>
<li><code><a title="icaparser.get_strongest_vep_consequence_rank" href="#icaparser.get_strongest_vep_consequence_rank">get_strongest_vep_consequence_rank</a></code></li>
<li><code><a title="icaparser.get_vep_consequence_for_rank" href="#icaparser.get_vep_consequence_for_rank">get_vep_consequence_for_rank</a></code></li>
<li><code><a title="icaparser.get_vep_priority_for_consequence" href="#icaparser.get_vep_priority_for_consequence">get_vep_priority_for_consequence</a></code></li>
<li><code><a title="icaparser.get_vep_rank_for_consequence" href="#icaparser.get_vep_rank_for_consequence">get_vep_rank_for_consequence</a></code></li>
<li><code><a title="icaparser.split_multi_sample_json_file" href="#icaparser.split_multi_sample_json_file">split_multi_sample_json_file</a></code></li>
<li><code><a title="icaparser.strip_json_file" href="#icaparser.strip_json_file">strip_json_file</a></code></li>
<li><code><a title="icaparser.strip_json_files" href="#icaparser.strip_json_files">strip_json_files</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>