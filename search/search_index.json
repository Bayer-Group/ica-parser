{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the icaparser Python package","text":"<p>This Python package provides functions for parsing JSON files created by Illumina's Connected Annotations (ICA)pipeline.  ICA annotates mutations with \u201aa set of tools and data sources. This package allows to:</p> <ul> <li>Strip JSON files from variants that do not pass quality criteria</li> <li>Load all mutations from a stripped Illumina Connected Annotations JSON file</li> <li>Filter mutations based on annotations and positions</li> <li>Create annotated tables of filtered mutations</li> </ul> <p>See the examples and the API documentation for further details.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#stripping-very-large-json-files","title":"Stripping very large JSON files","text":"<p>Some JSON files from Illumina TSO panels (for example, TSO500) are not QC filtered and contain all detected genomic variants, irrespective of whether they pass the quality criteria. Such files can get very large, too large to be processed by any JSON parser. If your JSON file does not contain only QC-filtered variants (\"PASS\"), it needs to be stripped (filtered) first before using the icaparser module for further processing.</p> <p>The code below can be run in Python in a terminal or in a Jupyter notebook. Terminal is recommended.  </p> <pre><code>import icaparser as icap\nicap.strip_json_files(source_dir='../Data/Original', target_dir='../Data/Derived')\n</code></pre>"},{"location":"examples/#simple-example","title":"Simple example","text":"<p>The code below is the Hello World example for reading and filtering ICA JSON files with default filtering rules. For more sophisticated filtering options, see the API reference.</p> <pre><code>import icaparser as icap\njson_files = icap.get_dna_json_files('../Data/Derived')\nfirst_file = json_files[0]\n# Get the annotation data sources\nicap.get_data_sources(first_file)\n# Get pipeline run metadata\nicap.get_pipeline_metadata(json_files)\n# Get a mutation table\nmut_table = icap.get_mutation_table_for_files(json_files)\n</code></pre>"},{"location":"installation/","title":"Installation instructions","text":""},{"location":"installation/#installation-of-the-icaparser-package","title":"Installation of the icaparser package","text":"<p>It is recommended to create a new virtual environment with Python &gt;= 3.9 and to install the icaparser package in that environment. Activate the environment and run:</p> <pre><code>pip install \"git+https://github.com/Bayer-Group/ica-parser.git#subdirectory=icaparser\"\n</code></pre> <p>If you want to install a particular development branch, use</p> <pre><code>pip install \"git+https://github.com/Bayer-Group/ica-parser.git@BRANCHNAME#subdirectory=icaparser\"\n</code></pre> <p>If you use Jupyter notebooks, the virtual environment should be added as a new Jupyter kernel. See Using Virtual Environments in Jupyter Notebook and Python - Parametric Thoughts how to do that.</p>"},{"location":"installation/#installation-of-ipywidgets","title":"Installation of ipywidgets","text":"<p>Required for progress bars in Jupyter. Please refer to the Jupyter or JupyterLab documentation how to install the widgets. For example:</p> <pre><code>conda install jupyter # if not installed yet\nconda install jupyterlab_widgets\njupyter labextension install jupyter-matplotlib\njupyter lab build\nexit\n</code></pre> <p>\u2192 Restart Jupyter</p>"},{"location":"reference/","title":"API documentation","text":"<p>Parser for JSON files from Illumina Connected Annotations pipeline.</p>"},{"location":"reference/#icaparser.icaparser.add_gene_types","title":"<code>add_gene_types(positions)</code>","text":"<p>Adds the gene type to each transcript.</p> <p>Transcripts will be annotated with the gene type (oncogene, tsg, mixed) by adding a new attribute <code>geneType</code>. Only transcripts with one of these three gene types get this additional annotation. Other transcripts will not get the <code>geneType</code> attribute.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of filtered or unfiltered positions from JSON files</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list of positions with additional annotation of transcripts</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions = icap.add_gene_types(positions)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.apply_mutation_classification_rules","title":"<code>apply_mutation_classification_rules(positions, rule_set=get_default_mutation_classification_rules(), gene_type_map=get_default_gene_type_map(), hide_progress=False)</code>","text":"<p>Applies mutation classification rules to all positions.</p> <p>Each mutation is categorized for each isoform that overlaps with the genomic position of the mutation. Each transcript which passed the \"mutated\" or \"uncertain\" rule of the classification rules gets a new attribute <code>mutation_status</code> with the value \"mutated\" or \"uncertain\".</p> <p>In addition to classifying mutations based on their impact on transcript isoforms, this function also assembles the mutation status on sample and gene level without further aggregation. The impact depends on the type of gene (\"gof\" or \"lof\"), so the impacts are assembled separately for each gene type:</p> <p><code>sample_id</code> \u2192 <code>gene</code> \u2192 <code>gene_type</code> \u2192 <code>variant_id</code> \u2192 <code>mutationStatus</code></p> <p>The impact of a particular mutational variant can be different for different overlapping transcript variants of a gene, and the transcript variants can also belong to different genes. The strongest impact on any overlapping transcript of a gene is defined as the impact of that mutational variant on the gene. The analyst must decide which isoforms are used to classify genes. For example, only canonical transcripts may be considered. Alternatively, all transcripts or a subset of transcripts may be used. Therefore, it is necessary to first apply transcript-level filters to all genomic positions  before determining the mutation status of genes.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of positions</p> </li> <li> <code>rule_set</code>         \u2013          <p>rules for classifying \"gof\" and \"lof\" genes. See also <code>get_default_mutation_classification_rules()</code> for an example if the default rule set needs to be modified.</p> </li> <li> <code>gene_type_map</code>         \u2013          <p>dictionary for mapping gene types to canonical gene types. See also <code>get_default_gene_type_map()</code> for an example if the default mapping table needs to be modified.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list of positions and a dictionary with assembled and aggregated</p> </li> <li>         \u2013          <p>mutations</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions, sample_muts = icap.apply_mutation_classification_rules(positions)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.cleanup_cosmic","title":"<code>cleanup_cosmic(positions)</code>","text":"<p>Remove Cosmic entries with alleles not matching the variant alleles.</p> <p>ICA attaches Cosmic entries to variants based on position only, which leads to wrong assignments of Cosmic entries to variants. This function removes all Cosmic entries from a variant for which reference and altered alleles do not match those of the variant.</p> <p>Filtering is done in place.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of positions to clean up</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list of positions with cleaned up Cosmic entries</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.common_variant_filter","title":"<code>common_variant_filter(variant, max_af=0.01)</code>","text":"<p>Get a variant filter based on GnomAD, GnomAd Exome, and 1000 Genomes.</p> <p>Returns True if none of the maximum allele frequencies from GnomAD, GnomAD Exome and 1000 Genomes is larger than <code>max_af</code>.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>max_af</code>         \u2013          <p>the mixum allele frequences threshold</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A bool</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.explode_consequence","title":"<code>explode_consequence(mutation_table, inplace=False)</code>","text":"<p>Explode the VEP consequence column of a mutation table.</p> <p>Exploding the VEP consequence column with the standard Pandas <code>explode()</code> function would return consquences as strings, not as ordered categories. This function will instead return a consequence columns which is an ordered category. The categories are ordered by their impact.</p> <p>Parameters:</p> <ul> <li> <code>mutation_table</code>         \u2013          <p>the mutation table to explode</p> </li> <li> <code>inplace</code>         \u2013          <p>if True, then modify the mutation_table in place instead of returning a new object</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.explode_consequence(mutation_table, inplace=True)\n</code></pre> <pre><code>&gt;&gt;&gt; mutation_table_exploded = icap.explode_consequence(mutation_table)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.filter_positions_by_transcripts","title":"<code>filter_positions_by_transcripts(positions, filter_func)</code>","text":"<p>Filter positions based on a filter function for transcripts.</p> <p>Apply a filter function to all transcripts of each position. Transcripts not passing the filter are removed from a position. Positions without any transcripts passing the filter are removed from the returned list.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of positions to filter</p> </li> <li> <code>filter_func</code>         \u2013          <p>function taking a transcript and returning a bool.          True means to keep the transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul> Example <p>is_canonical_transcript = lambda x: x.get('isCanonical', False) canonical_positions = icap.filter_positions_by_transcripts(         non_common_positions,         is_canonical_transcript     )</p>"},{"location":"reference/#icaparser.icaparser.filter_positions_by_variants","title":"<code>filter_positions_by_variants(positions, filter_func)</code>","text":"<p>Filter positions based on a filter function for variants.</p> <p>Apply a filter function to all variants of each position. Variants not passing the filter are removed from a position. Positions without any variants passing the filter are removed from the returned list.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of positions to filter</p> </li> <li> <code>filter_func</code>         \u2013          <p>function taking a variant and returning a bool.          True means to keep the variant.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul> Example <p>import icaparser as icap ax_af = 0.01 is_not_common_variant = lambda x: icap.common_variant_filter(x, max_af) non_common_positions = icap.filter_positions_by_variants(         positions,         is_not_common_variant     )</p>"},{"location":"reference/#icaparser.icaparser.filter_variants_by_transcripts","title":"<code>filter_variants_by_transcripts(variants, filter_func)</code>","text":"<p>Filter variants based on a filter function for transcripts.</p> <p>Apply a filter function to all transcripts of each variant. Transcripts not passing the filter are removed from a variant. Variants without any transcripts passing the filter are removed from the returned list.</p> <p>Parameters:</p> <ul> <li> <code>variants</code>         \u2013          <p>list of variants to filter</p> </li> <li> <code>filter_func</code>         \u2013          <p>function taking a transcript and returning a bool.          True means to keep the transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_aggregated_mutation_table","title":"<code>get_aggregated_mutation_table(positions, sample_muts=None, mutation_classification_rules=get_default_mutation_classification_rules(), mutation_aggregation_rules=get_default_mutation_aggregation_rules(), gene_type_map=get_default_gene_type_map(), hide_progress=False)</code>","text":"<p>Returns a sample-gene-mutationStatus table.</p> <p>This function applies mutation classification rules to all mutational variants and aggregates the mutations according to the aggregation rules. This results in a table with one row for each sample-gene pair. The table contains several columns with impacts for \"lof\" and \"gof\" on allele level and gene level and with one additional column with the maximum impact for both allele and gene level.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>list of positions. If sample_muts is also specified, it is assumed that the positions have already been processed previously by <code>apply_mutation_classification_rules</code> and we do not have to run mutation classification again.</p> </li> <li> <code>sample_muts</code>         \u2013          <p>if <code>apply_mutation_classification_rules</code> has been run before, you can use the second return value of that function as the sample_muts argument. This is helpful for very large datasets because otherwise <code>apply_mutation_classification_rules</code> will be run again as an internal call within <code>get_aggregated_mutation_table</code>, which is time consuming for very large data sets. This also means that if <code>sample_muts</code> are specified, the <code>mutation_classification_rules</code> argument is ignored and has no effect.</p> </li> <li> <code>mutation_classification_rules</code>         \u2013          <p>rules for classifying single mutations. See <code>get_default_mutation_classification_rules()</code> for details.</p> </li> <li> <code>mutation_aggregation_rules</code>         \u2013          <p>rules for aggregation mutations. See <code>get_default_mutation_aggregation_reles()</code> for details.</p> </li> <li> <code>gene_type_map</code>         \u2013          <p>dictonary for mapping gene types to canonical gene types. See <code>get_default_gene_type_map()</code> for details.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame with the mutation table.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_biotype_priority","title":"<code>get_biotype_priority(biotype)</code>","text":"<p>Get the numeric priority of a biotype.</p> <p>The numeric priority of a biotype that is returned by this function is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl. Biotypes are 'protein_coding', 'LRG_gene', ,'miRNA', ...</p> <p>Parameters:</p> <ul> <li> <code>biotype</code>         \u2013          <p>a string with a single biotype</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>An integer, smaller values mean higher priority</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_clinvar","title":"<code>get_clinvar(variant)</code>","text":"<p>Get a table of all ClinVar annotations for a variant.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_clinvar_max_significance","title":"<code>get_clinvar_max_significance(variant, ordered_significances=_CLINVAR_ORDERED_SIGNIFICANCES)</code>","text":"<p>Get the maximum signifinance for all ClinVar annotations of a variant.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>ordered_significances</code>         \u2013          <p>ranked order of ClinVar significances</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A string</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_consequences","title":"<code>get_consequences(transcript)</code>","text":"<p>Get a list of consequences for a transcript</p> <p>A list of consequences for a transcript is returned. If any of the annotated consequences is a combination if single consequences, separated by ampersands ('&amp;') or commas, such a consequence is split into single consequences.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>         \u2013          <p>the transcript to get the consequences for</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list of strings</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_cosmic_max_sample_count","title":"<code>get_cosmic_max_sample_count(variant, only_allele_specific=True)</code>","text":"<p>Get the maximum sample count for all Cosmic annotations of a variant.</p> <p>A variant can have no, one or multiple associated Cosmic identifiers. This function returns the maximum sample count of all Cosmic identifers. For each Cosmic identifiers, sample numbers are summed up across all indications. Returns 0 if no Cosmic identifier exists for this variant.</p> <p>The 'only_allele_specific' argument is used to exclude Cosmic entries that annotate the same chromosomal location but an allele that is different from the allele of the annotated variant. ICA annotates a variant with all Cosmic entries for that chromosomal location, irrespective of alleles. When counting Cosmic samples, this leads to an overestimation of Cosmic sample counts for a particular variant. Therefore, 'only_allele_specific' is True by default to count only samples from Cosmic entries with matching alleles. Occasionally, it may be desired, though, to count all samples with mutations at a given position, irrespective of allele. For example, several different alleles at a functional site of a gene can lead to function-disrupting mutations, so we want to get the maximum sample count for any allele at that position. One might also think of adding the sample counts for all Cosmic entries annotating a variant, but this does not work  due to redundancy of Cosmic entries. Older Cosmic versions often included the same sample in different Cosmic entries. And newer Cosmic versions often have multiple entries for an allele, one for each transcript variant, with the same underlying samples.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>only_allele_specific</code>         \u2013          <p>consider only cosmic entries with alleles                   matching the allele of the annotated variant</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>An integer</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_data_sources","title":"<code>get_data_sources(file)</code>","text":"<p>Extract a table with annotation data sources from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_default_gene_type_map","title":"<code>get_default_gene_type_map()</code>","text":"<p>Returns the default gene type map.</p> <p>The canonical gene types are <code>gof</code>, <code>lof</code>, and the union of both. Genes that need to be activated to drive a tumor are of type <code>gof</code>. Genes that need to be deactivated to drive a tumor are of type <code>lof</code>. Genes that need to be activated or deactivated depending on the context are of the union of both types. Genes for which it is unknown if they need to be activated or deactivated are also annotated with both types. Genes can be originally annotated with other type names than the canonical ones. The gene type map is used to map these other gene type names to the canonical gene types.</p> <p>The default map is:</p> <ul> <li><code>oncogene</code> \u2192 <code>{\"gof\"}</code></li> <li><code>tsg</code> \u2192 <code>{\"lof\"}</code></li> <li><code>Act</code> \u2192 <code>{\"gof\"}</code></li> <li><code>LoF</code> \u2192 <code>{\"lof\"}</code></li> <li><code>mixed</code> \u2192 <code>{\"gof\", \"lof\"}</code></li> <li><code>ambiguous</code> \u2192 <code>{\"gof\", \"lof\"}</code></li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A dictionary with mappings from gene types to canonical gene types</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_gene_type_map()\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_default_mutation_aggregation_rules","title":"<code>get_default_mutation_aggregation_rules()</code>","text":"<p>Returns the default mutation aggregation rules.</p> <p>Two types of the mutation status of a gene are introduced - allele level and gene level:</p> <ul> <li>For \"gof\" genes (like oncogenes) it is sufficient if one of the alleles of     one of the relevant isoforms has an activating mutation.</li> <li>For \"lof\" genes (like tumor suppressor genes) all alleles of all relevant     isoforms need to be functionally disrupted, either by mutations or by     other means.</li> <li>For Mixed and Other genes, the impact of a mutation is defined as the     highest impact according to \"gof\" rules and \"lof\" rules.</li> </ul> <p>For \"gof\" genes, the allele and gene level classifications are identical unless there is additional information about activating modifications other than mutations. For \"lof\" genes, allele and gene level classifications may be different. For example, a truncating mutation of a tumor suppressor gene is functionally disruptive for the affected allele. However, there may be other functionally active alleles of the same gene, i.e., the gene itself may still be active. All alleles of such a gene must be dysfunctional, either by additional mutations or by other processes, such as copy number deletions or hypermethylation. Therefore, a single variant that is disruptive at the allele level is not necessarily also disruptive at the gene level. For \"lof\" genes, we usually do not have enough information for a reliable estimation of functional effects. Instead, some heuristic ules must be applied, and the analyst must decide whether to work with allele-level or gene-level classifications. We designate a \"lof\" gene as functionally disrupted (strong impact) if it has at least two mutations with either strong impact or uncertain impact. If a \"lof\" gene has only one of these mutations, it is designated as uncertain impact at the gene level, even if one of these mutations has a strong impact at the allele level. By categorizing effects at both allele and gene levels, we retain the flexibility to decide in downstream analyses how to merge some of these categories for subsequent statistical calculations.</p> <p>Additional filters based on publications, white lists and black lists for mutations can be applied. These are not part of the first version and will be added later. White and black lists can be based, for example, on ClinVar and on the publication by Hess et al. (2019).</p> <p>Returns:</p> <ul> <li>         \u2013          <p>A dictionary</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_mutation_aggregation_rules()\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_default_mutation_classification_rules","title":"<code>get_default_mutation_classification_rules(cosmic_threshold=10)</code>","text":"<p>Returns the default rules for classifying mutations.</p> <p>Defines the default rules for classifying mutations. The returned dictonary has keys \"gof\" and \"lof\", and the respective values are the rule sets for these gene types. A rule set is again a dictionary with the keys \"mutated\" and \"uncertain\". The values for \"mutated\" or \"uncertain\" are dictionaries with three filter functions, a \"position_filter\", a \"variant_filter\", and a \"transcript filter\". For example, a transcript will be called \"mutated\" if all three filters for \"mutated\" return True, and it will be called \"uncertain\", if all three filter functions for \"uncertain\" return True.</p> <p>Parameters:</p> <ul> <li> <code>cosmic_threshold</code>         \u2013          <p>for \"gof\" genes, this is the \"hotspot threshold\" for Cosmic, i.e., the minimum number of samples in Cosmic having that mutation to consider a mutation a hot spot and, therefore, call the mutation \"mutated\". If the number of Cosmic samples is smaller, the mutation is called \"uncertain\".</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A dictionary with mutation classification rules</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_mutation_classification_rules()\n&gt;&gt;&gt; icap.get_default_mutation_classification_rules(cosmic_threshold=20)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_dna_json_files","title":"<code>get_dna_json_files(base_dir, pattern='*MergedVariants_Annotated_filtered.json.gz')</code>","text":"<p>Find DNA annotation JSON files in or below <code>base_dir</code>.</p> <p>Searches for ICA DNA annotation JSON files in and below <code>base_dir</code>. All file names matching <code>pattern</code> are returned.</p> <p>Parameters:</p> <ul> <li> <code>base_dir</code>         \u2013          <p>base directory of directory subtree where to search       for DNA annotation JSON files</p> </li> <li> <code>pattern</code>         \u2013          <p>files names matching this pattern are returned</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list of file names</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gene_type","title":"<code>get_gene_type(gene_symbol)</code>","text":"<p>Get the gene type (oncogene, tsg, mixed) for a gene.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbol</code>         \u2013          <p>the gene symbol of the gene</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>a string</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_genes","title":"<code>get_genes(file)</code>","text":"<p>Extract gene annotation from a ICA JSON file.</p> <p>The <code>genes</code> section of ICA JSON files is optional. If this section is not included in the file, an empty list is returned.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gnomad_exome_max_af","title":"<code>get_gnomad_exome_max_af(variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</code>","text":"<p>Get the maximum allele frequency for gnomAD Exome.</p> <p>Get the maximum allele frequences across all major cohorts annotated by gnomAD, Exome  excluding bottleneck populations (Ashkenazy Jews and Finish) and other.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>cohorts</code>         \u2013          <p>subpopulations to include</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A float</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gnomad_max_af","title":"<code>get_gnomad_max_af(variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</code>","text":"<p>Get the maximum allele frequency for gnomAD.</p> <p>Get the maximum allele frequences across all major cohorts annotated by gnomAD, excluding bottleneck populations (Ashkenazy Jews and Finish) and other.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>cohorts</code>         \u2013          <p>subpopulations to include</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A float</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_header","title":"<code>get_header(file)</code>","text":"<p>Extract the header element from a ICA JSON file.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A dictionary with the header from the JSON file</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_header_scalars","title":"<code>get_header_scalars(file)</code>","text":"<p>Extract a table with all scalar attributes from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_max_af","title":"<code>get_max_af(variant, source, cohorts=None)</code>","text":"<p>Get the maximum allele frequency for a particular annotation source.</p> <p>Get the maximum allele frequency across all cohorts annotated by the annotation source.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> <li> <code>source</code>         \u2013          <p>the annotation source to use</p> </li> <li> <code>cohorts</code>         \u2013          <p>subpopulations to include; include all if cohorts == None</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A float</p> </li> </ul> Example <p>import icaparser as icap icap.get_max_af(variant, 'gnomad')</p>"},{"location":"reference/#icaparser.icaparser.get_multi_sample_positions","title":"<code>get_multi_sample_positions(files, *args, **kwargs)</code>","text":"<p>Extract all positions for a set of ICA JSON files.</p> <p>The sample id is stored as an additional new attribute of the <code>samples</code> element of a position. The <code>samples</code> element is a list, although ICA usually only creates single sample JSON files.</p> <p>Parameters:</p> <ul> <li> <code>files</code>         \u2013          <p>names of the ICA JSON files</p> </li> <li> <code>args</code>         \u2013          <p>extra arguments forwarded to get_positions()</p> </li> <li> <code>kwargs</code>         \u2013          <p>extra named arguments forwarded to get_positions()</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions = icap.get_multi_sample_positions(json_files)\n&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_files","title":"<code>get_mutation_table_for_files(json_files, max_af=0.01, min_vep_consequence_priority=6, min_cosmic_sample_count=0, only_canonical=False, extra_variant_filters=[], extra_transcript_filters=[])</code>","text":"<p>Get an annotated table of all filtered transcripts from a list of ICA JSON files.</p> <p>Load all positions from a list of ICA JSON files and filter them. Positions having any remaining variants and transcripts passing the filter are returned as an annotated table.</p> <p>Parameters:</p> <ul> <li> <code>files</code>         \u2013          <p>list of ICA JSON files</p> </li> <li> <code>max_af</code>         \u2013          <p>maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.     Only variants with maximum allele frequencies below this threshold     will be returned.</p> </li> <li> <code>min_vep_consequence_priority</code>         \u2013          <p>only transcripts with a minimum VEP     consequence priority not larger than this threshold will be retained</p> </li> <li> <code>min_cosmic_sample_count</code>         \u2013          <p>only variants with a maximum cosmic sample count     not lower than this threshold will be retained</p> </li> <li> <code>only_canonical</code>         \u2013          <p>if true, only canonical transcripts will be retained</p> </li> <li> <code>extra_variant_filters</code>         \u2013          <p>any additional filters to apply to variants.     Filters shall return True to keep a variant.</p> </li> <li> <code>extra_transcript_filters</code>         \u2013          <p>any additional filters to apply to transcripts.     Filters shall return True to keep a transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; extra_transcript_filters = [\n        lambda x: x.get('source', '') == 'Ensembl',\n        lambda x: x.get('hgnc', '') == 'KRAS'\n    ]\n&gt;&gt;&gt; mut_table = icap.get_mutation_table_for_files(\n        json_files,\n        extra_transcript_filters=extra_transcript_filters\n    )\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_position","title":"<code>get_mutation_table_for_position(position)</code>","text":"<p>Get an annotated table of all transcripts.</p> <p>Returns an annotated table of all transcripts that are affected by a mutation at a position.</p> <p>Parameters:</p> <ul> <li> <code>position</code>         \u2013          <p>the position to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_positions","title":"<code>get_mutation_table_for_positions(positions, hide_progress=False)</code>","text":"<p>Get an annotated table of all transcripts for all positions.</p> <p>Returns an annotated table of all transcripts that are affected by a mutation at any of the position.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>the positions to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_onekg_max_af","title":"<code>get_onekg_max_af(variant)</code>","text":"<p>Get the maximum allele frequency for the 1000 Genomes Project.</p> <p>Get the maximum allele frequences across all cohorts annotated by the 1000 Genomes Project.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>         \u2013          <p>the variant to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A float</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_pipeline_metadata","title":"<code>get_pipeline_metadata(files)</code>","text":"<p>Extract a table with metadata annotation pipeline run from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A pandas.DataFrame</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_position_by_coordinates","title":"<code>get_position_by_coordinates(positions, chromosome, position)</code>","text":"<p>Extract a particular position from a position list.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>         \u2013          <p>a list of positions</p> </li> <li> <code>chromosome</code>         \u2013          <p>name of the chromosome</p> </li> <li> <code>position</code>         \u2013          <p>numeric posion on the chromosome</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A dict</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_position_by_coordinates(positions, 'chr1', 204399064)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_positions","title":"<code>get_positions(file, variant_filters=[], transcript_filters=[])</code>","text":"<p>Extract all positions from a ICA JSON file.</p> <p>The sample id is stored as an additional new attribute of the <code>samples</code> element of a position. The <code>samples</code> element is a list, although ICA usually only creates single sample JSON files.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> <li> <code>variant_filters</code>         \u2013          <p>any filters to apply to variants.     Filters shall return True to keep a variant.</p> </li> <li> <code>transcript_filters</code>         \u2013          <p>any filters to apply to transcripts.     Filters shall return True to keep a transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A list</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transcript_filters = [\n        lambda x: x.get('source', '') == 'Ensembl',\n        lambda x: x.get('hgnc', '') == 'KRAS'\n    ]\n&gt;&gt;&gt; positions = icap.get_sample_positions(\n        json_file,\n        transcript_filters = transcript_filters\n    )\n&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_sample","title":"<code>get_sample(file, suffix='(-D[^.]*)?\\\\.bam')</code>","text":"<p>Extract the sample name from a ICA JSON file.</p> <p>Parameters:</p> <ul> <li> <code>file</code>         \u2013          <p>name of the ICA JSON file</p> </li> <li> <code>suffix</code>         \u2013          <p>regular expression to remove from the sample name in the JSON file. Defaults to '(-D[^.]*)?.bam'.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A string with the name of the sample annotated in the JSON file</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_name","title":"<code>get_strongest_vep_consequence_name(transcript)</code>","text":"<p>Get the name of the strongest VEP consequence for a transcript.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>         \u2013          <p>the transcript to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A string</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_priority","title":"<code>get_strongest_vep_consequence_priority(transcript)</code>","text":"<p>Get the strongest priority of VEP consequence for a transcript.</p> <p>Get the strongest numeric priority of all VEP consequences for a transcript. Smaller numeric priorities mean stronger impact.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>         \u2013          <p>the transcript to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>An integer</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_rank","title":"<code>get_strongest_vep_consequence_rank(transcript)</code>","text":"<p>Get the strongest rank of VEP consequences for a transcript.</p> <p>Get the strongest numeric rank of all VEP consequences for a transcript. Smaller ranks mean stronger impact.</p> <p>The priority of consequences is taken into account first. So if two consequences have different priorities, the consequence with the higher priority (lower priority number) will be used, and the rank for this consequence will be returned. If there are multiple consequences with the same priority, the lowest (strongest) rank will be returned.</p> <p>For clarification: ranks are unique, i.e. all VEP consequences ordered as listed on the VEP documentation page get the row number of this table assigned as rank.</p> <p>However, several consequences can have the same priority (e.g., stop gained and frameshift have the same priority). Priorities are copied from vcf2maf.pl.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>         \u2013          <p>the transcript to investigate</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>An integer</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_vep_consequence_for_rank","title":"<code>get_vep_consequence_for_rank(rank)</code>","text":"<p>Get the VEP consequence term of a numeric rank.</p> <p>Parameters:</p> <ul> <li> <code>rank</code>         \u2013          <p>the numeric rank of the consequence term</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>A string</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_vep_priority_for_consequence","title":"<code>get_vep_priority_for_consequence(consequence)</code>","text":"<p>Get the numeric priority of a VEP consequence term.</p> <p>The numeric priority of a consequence that is returned by this function   is the same as defined by https://github.com/mskcc/vcf2maf/blob/master/vcf2maf.pl.</p> <p>Parameters:</p> <ul> <li> <code>consequence</code>         \u2013          <p>the consequence term of the mutation</p> </li> </ul> <p>Returns:       An integer</p>"},{"location":"reference/#icaparser.icaparser.get_vep_rank_for_consequence","title":"<code>get_vep_rank_for_consequence(consequence)</code>","text":"<p>Get the numeric rank of a VEP consequence term.</p> <p>The numeric rank of a consequence that is the position of the consequence in this list of consequences at https://www.ensembl.org/info/genome/variation/prediction/predicted_data.html</p> <p>Parameters:</p> <ul> <li> <code>consequence</code>         \u2013          <p>the consequence term of the mutation</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>An integer</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.split_multi_sample_json_file","title":"<code>split_multi_sample_json_file(json_file, output_dir)</code>","text":"<p>Splits a multi-sample JSON file into sample specifc JSON files.</p> <p>This function reads a multi-sample JSON file that was generated by annotating a multi-sample VCF file with ICA and splits it into sample-specific JSON files.</p> <p>Annotating very many single-sample VCF files with ICA is very time consuming, because ICA reads all annotation sources for each VCF file and this is dominating the runtime of ICA. It is therefore helpful to first merge many single-sample VCF files into one or a small number of multi-sample VCF files (for example, with <code>bcftools merge</code>), to annotate the multi-sample VCF file with ICA, and then to split the multi-sample JSON output of ICA into single-sample JSON files. These single-sample JSON files are required for the rest of this package.</p> <p>Parameters:</p> <ul> <li> <code>json_file</code>         \u2013          <p>the multi-sample json input file</p> </li> <li> <code>output_dir</code>         \u2013          <p>the directory where to write the single sample JSON files. The directory will be created if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>Nothing</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.strip_json_file","title":"<code>strip_json_file(ifname, ofname)</code>","text":"<p>Reduce the JSON file size by keeping only 'PASS' variants.</p> <p>JSON files from Illumina's ICA pipeline can be very large because they contain any deviation from the reference genome, irrespective of the quality of the mutation call. Gzip compressed JSON files with sizes in the gigabyte range cannot be processed by JSON packages that read the entire file into memory. It is necessary to first reduce the size of JSON files by removing all variants that do not meet Illumina's quality criteria.</p> <p>This function reads a single JSON file and creates a single JSON outpout file by removing all variants that do not pass Illumina's quality criteria.</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>         \u2013          <p>name of the  input file</p> </li> <li> <code>ofname</code>         \u2013          <p>name of the output file</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>Nothing</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.strip_json_files","title":"<code>strip_json_files(source_dir, target_dir, pattern='*.json.gz')</code>","text":"<p>Strip all JSON files of a project by keeping only 'PASS' variants.</p> <p>JSON files from Illumina's ICA pipeline can be very large because they contain any deviation from the reference genome, irrespective of the quality of the mutation call. Gzip compressed JSON files with sizes in the gigabyte range cannot be processed by JSON packages that read the entire file into memory. It is necessary to first reduce the size of JSON files by removing all variants that do not meet Illumina's quality criteria.</p> <p>This function searches <code>source_dir</code> recursively for all files matching the <code>file_pattern</code>. Each of those files is processed and a stripped version keeping only variants that PASS Illumina's quality criteria is created. The output file has the same name as the input file. The directory structure below <code>source_dir</code> is replicated in <code>target_dir</code>. Output files get the suffix '_filtered.json.gz'.\u201a</p> <p>Parameters:</p> <ul> <li> <code>source_dir</code>         \u2013          <p>directory where to search for input JSON files</p> </li> <li> <code>target_dir</code>         \u2013          <p>directory where to save the stripped outpout JSON files</p> </li> <li> <code>file_pattern</code>         \u2013          <p>files matching this pattern will be processed</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>Nothing</p> </li> </ul> Example <p>strip_json_files('../Data/Original', '../Data/Derived')</p>"}]}